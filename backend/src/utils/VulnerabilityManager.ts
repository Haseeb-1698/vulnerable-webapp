import { Express, Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';

export interface VulnerabilityConfig {
  enabled: boolean;
  endpoint?: string;
  component?: string;
  vulnerableCode: string;
  secureCode: string;
  testPayloads: string[];
  description: string;
  cweId: string;
}

export interface VulnerabilityState {
  sqlInjection: VulnerabilityConfig;
  xss: VulnerabilityConfig;
  idor: VulnerabilityConfig;
  sessionManagement: VulnerabilityConfig;
  ssrfLfi: VulnerabilityConfig;
}

export class VulnerabilityManager {
  private app: Express;
  private prisma: PrismaClient;
  private vulnerabilities: VulnerabilityState;
  private originalRoutes: Map<string, any> = new Map();

  constructor(app: Express, prisma: PrismaClient) {
    this.app = app;
    this.prisma = prisma;
    this.vulnerabilities = this.initializeVulnerabilities();
  }

  private initializeVulnerabilities(): VulnerabilityState {
    return {
      sqlInjection: {
        enabled: true,
        endpoint: '/api/tasks/simple-search',
        vulnerableCode: this.getSQLInjectionVulnerableCode(),
        secureCode: this.getSQLInjectionSecureCode(),
        testPayloads: [
          "' OR 1=1 --",
          "' UNION SELECT 1, username, password FROM users WHERE '1'='1",
          "' AND (SELECT COUNT(*) FROM users) > 0--",
          "' OR '1'='1#",
          "test' OR 1=1 --"
        ],
        description: 'SQL Injection vulnerability in search functionality',
        cweId: 'CWE-89'
      },
      xss: {
        enabled: true,
        component: 'CommentDisplay',
        vulnerableCode: this.getXSSVulnerableCode(),
        secureCode: this.getXSSSecureCode(),
        testPayloads: [
          "<script>alert('XSS')</script>",
          "<img src=x onerror='alert(document.cookie)'>",
          "<svg onload='fetch(\"/api/steal\", {method:\"POST\", body:localStorage.token})'>"
        ],
        description: 'Cross-Site Scripting vulnerability in comment system',
        cweId: 'CWE-79'
      },
      idor: {
        enabled: true,
        endpoint: '/api/tasks/:id',
        vulnerableCode: this.getIDORVulnerableCode(),
        secureCode: this.getIDORSecureCode(),
        testPayloads: [
          'Increment task ID to access other users\' tasks',
          'Direct URL manipulation',
          'Automated ID enumeration'
        ],
        description: 'Insecure Direct Object Reference vulnerability',
        cweId: 'CWE-639'
      },
      sessionManagement: {
        enabled: true,
        component: 'AuthSystem',
        vulnerableCode: this.getSessionVulnerableCode(),
        secureCode: this.getSessionSecureCode(),
        testPayloads: [
          'Token stored in localStorage',
          'Weak JWT secret',
          'No token refresh mechanism'
        ],
        description: 'Insecure session management vulnerabilities',
        cweId: 'CWE-384'
      },
      ssrfLfi: {
        enabled: true,
        endpoint: '/api/users/avatar',
        vulnerableCode: this.getSSRFVulnerableCode(),
        secureCode: this.getSSRFSecureCode(),
        testPayloads: [
          'http://169.254.169.254/latest/meta-data/',
          'file:///etc/passwd',
          'http://localhost:6379/info'
        ],
        description: 'Server-Side Request Forgery and Local File Inclusion',
        cweId: 'CWE-918'
      }
    };
  }

  public getVulnerabilityState(): VulnerabilityState {
    return this.vulnerabilities;
  }

  public async toggleVulnerability(vulnType: keyof VulnerabilityState): Promise<boolean> {
    if (!this.vulnerabilities[vulnType]) {
      throw new Error(`Unknown vulnerability type: ${vulnType}`);
    }

    this.vulnerabilities[vulnType].enabled = !this.vulnerabilities[vulnType].enabled;
    
    // Hot-reload the endpoint if it exists
    if (this.vulnerabilities[vulnType].endpoint) {
      await this.reloadEndpoint(vulnType);
    }

    return this.vulnerabilities[vulnType].enabled;
  }

  private async reloadEndpoint(vulnType: keyof VulnerabilityState): Promise<void> {
    const config = this.vulnerabilities[vulnType];
    
    // This is a simplified hot-reload mechanism
    // In a real implementation, you might need more sophisticated route replacement
    console.log(`Reloading endpoint for ${vulnType}: ${config.endpoint}`);
    console.log(`Vulnerability enabled: ${config.enabled}`);
  }

  public getVulnerabilityConfig(vulnType: keyof VulnerabilityState): VulnerabilityConfig | null {
    return this.vulnerabilities[vulnType] || null;
  }

  // Code examples for each vulnerability type
  private getSQLInjectionVulnerableCode(): string {
    return `// VULNERABLE CODE - Raw SQL Query
app.get('/api/tasks/search', authenticateUser, async (req, res) => {
  const { query } = req.query;
  
  // DANGER: Direct string concatenation
  const sqlQuery = \`
    SELECT t.*, u.first_name, u.last_name 
    FROM tasks t 
    JOIN users u ON t.user_id = u.id 
    WHERE t.title LIKE '%\${query}%' 
    OR t.description LIKE '%\${query}%'
  \`;
  
  try {
    const result = await db.query(sqlQuery);
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});`;
  }

  private getSQLInjectionSecureCode(): string {
    return `// SECURE CODE - Parameterized Query
app.get('/api/tasks/search', authenticateUser, async (req, res) => {
  const { query } = req.query;
  
  // Input validation
  if (!query || query.length > 100) {
    return res.status(400).json({ error: 'Invalid search query' });
  }
  
  try {
    // Safe parameterized query using Prisma
    const tasks = await prisma.task.findMany({
      where: {
        AND: [
          { userId: req.user.id }, // Ensure user owns tasks
          {
            OR: [
              { title: { contains: query, mode: 'insensitive' } },
              { description: { contains: query, mode: 'insensitive' } }
            ]
          }
        ]
      },
      include: {
        user: { select: { firstName: true, lastName: true } }
      }
    });
    
    res.json(tasks);
  } catch (error) {
    // Safe error handling
    res.status(500).json({ error: 'Search failed' });
  }
});`;
  }

  private getXSSVulnerableCode(): string {
    return `// VULNERABLE CODE - Dangerous HTML Rendering
const CommentDisplay = ({ comment }) => {
  return (
    <div className="comment-content">
      {/* DANGER: Executes any JavaScript */}
      <div 
        dangerouslySetInnerHTML={{ __html: comment.content }}
        className="prose"
      />
      <div className="comment-meta">
        By: {comment.user.firstName} {comment.user.lastName}
      </div>
    </div>
  );
};`;
  }

  private getXSSSecureCode(): string {
    return `// SECURE CODE - Safe HTML Rendering
import DOMPurify from 'dompurify';

const CommentDisplay = ({ comment }) => {
  // Sanitize HTML content
  const sanitizedContent = DOMPurify.sanitize(comment.content);
  
  return (
    <div className="comment-content">
      {/* Safe: HTML is sanitized */}
      <div 
        dangerouslySetInnerHTML={{ __html: sanitizedContent }}
        className="prose"
      />
      <div className="comment-meta">
        By: {comment.user.firstName} {comment.user.lastName}
      </div>
    </div>
  );
};`;
  }

  private getIDORVulnerableCode(): string {
    return `// VULNERABLE CODE - No Authorization Check
app.get('/api/tasks/:id', authenticateUser, async (req, res) => {
  const { id } = req.params;
  
  try {
    // DANGER: No ownership verification
    const task = await prisma.task.findUnique({
      where: { id: parseInt(id) },
      include: {
        user: { select: { firstName: true, lastName: true } },
        comments: true
      }
    });
    
    if (!task) {
      return res.status(404).json({ error: 'Task not found' });
    }
    
    res.json(task);
  } catch (error) {
    res.status(500).json({ error: 'Server error' });
  }
});`;
  }

  private getIDORSecureCode(): string {
    return `// SECURE CODE - Proper Authorization
app.get('/api/tasks/:id', authenticateUser, async (req, res) => {
  const { id } = req.params;
  
  try {
    // Safe: Check ownership
    const task = await prisma.task.findFirst({
      where: { 
        id: parseInt(id),
        userId: req.user.id // Ensure user owns the task
      },
      include: {
        user: { select: { firstName: true, lastName: true } },
        comments: {
          include: {
            user: { select: { firstName: true, lastName: true } }
          }
        }
      }
    });
    
    if (!task) {
      return res.status(404).json({ error: 'Task not found' });
    }
    
    res.json(task);
  } catch (error) {
    res.status(500).json({ error: 'Server error' });
  }
});`;
  }

  private getSessionVulnerableCode(): string {
    return `// VULNERABLE CODE - Weak Session Management
const generateToken = (user) => {
  // DANGER: Weak secret and long expiration
  return jwt.sign(
    { userId: user.id, email: user.email },
    'weak-secret-key', // Should be strong, random secret
    { expiresIn: '30d' } // Overly long expiration
  );
};

// Frontend - Insecure token storage
const login = async (credentials) => {
  const response = await api.post('/auth/login', credentials);
  // DANGER: Token stored in localStorage
  localStorage.setItem('token', response.data.token);
  setUser(response.data.user);
};`;
  }

  private getSessionSecureCode(): string {
    return `// SECURE CODE - Strong Session Management
const generateToken = (user) => {
  // Safe: Strong secret and reasonable expiration
  return jwt.sign(
    { userId: user.id, email: user.email },
    process.env.JWT_SECRET, // Strong, random secret from env
    { expiresIn: '15m' } // Short expiration with refresh
  );
};

// Frontend - Secure token storage
const login = async (credentials) => {
  const response = await api.post('/auth/login', credentials);
  // Safe: Token in httpOnly cookie (handled by server)
  setUser(response.data.user);
  // No manual token storage needed
};`;
  }

  private getSSRFVulnerableCode(): string {
    return `// VULNERABLE CODE - No URL Validation
app.post('/api/users/avatar', authenticateUser, async (req, res) => {
  const { imageUrl, fetchFromUrl } = req.body;
  
  if (fetchFromUrl && imageUrl) {
    try {
      // DANGER: No URL validation - allows SSRF attacks
      const response = await axios.get(imageUrl, {
        timeout: 10000,
        maxRedirects: 5
      });
      
      // DANGER: Allows fetching internal services and files
      if (imageUrl.startsWith('file://')) {
        const filePath = imageUrl.replace('file://', '');
        const fileContent = fs.readFileSync(filePath, 'utf8');
        return res.json({ 
          success: true, 
          content: fileContent
        });
      }
      
      res.json({ success: true, data: response.data });
      
    } catch (error) {
      // DANGER: Error messages leak internal information
      res.status(500).json({ 
        error: 'Failed to fetch image',
        details: error.message,
        requestedUrl: imageUrl
      });
    }
  }
});`;
  }

  private getSSRFSecureCode(): string {
    return `// SECURE CODE - URL Validation and Restrictions
const ALLOWED_DOMAINS = ['example.com', 'trusted-cdn.com'];
const BLOCKED_IPS = ['127.0.0.1', '10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16'];

app.post('/api/users/avatar', authenticateUser, async (req, res) => {
  const { imageUrl, fetchFromUrl } = req.body;
  
  if (fetchFromUrl && imageUrl) {
    try {
      // Safe: Validate URL and domain
      const url = new URL(imageUrl);
      
      if (!ALLOWED_DOMAINS.includes(url.hostname)) {
        return res.status(400).json({ error: 'Domain not allowed' });
      }
      
      if (url.protocol === 'file:') {
        return res.status(400).json({ error: 'File protocol not allowed' });
      }
      
      // Safe: Restricted HTTP client
      const response = await axios.get(imageUrl, {
        timeout: 5000,
        maxRedirects: 2,
        maxContentLength: 1024 * 1024 // 1MB limit
      });
      
      res.json({ success: true, message: 'Image processed' });
      
    } catch (error) {
      // Safe: Generic error message
      res.status(500).json({ error: 'Failed to process image' });
    }
  }
});`;
  }
}