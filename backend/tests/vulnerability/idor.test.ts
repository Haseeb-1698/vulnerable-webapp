import request from 'supertest';
import { app } from '../../src/server';
import { prisma, setupTestDatabase, testUsers } from '../setup';
import jwt from 'jsonwebtoken';

describe('IDOR (Insecure Direct Object References) Vulnerability Tests', () => {
  let user1Token: string;
  let user2Token: string;
  let user1Id: number;
  let user2Id: number;
  let user1TaskId: number;
  let user2TaskId: number;
  let user1CommentId: number;
  let user2CommentId: number;

  beforeAll(async () => {
    const users = await setupTestDatabase();
    user1Id = users.user1.id;
    user2Id = users.user2.id;

    // Generate JWT tokens for testing
    user1Token = jwt.sign(
      { userId: user1Id, email: testUsers.user1.email },
      process.env.JWT_SECRET || 'weak-secret-key',
      { expiresIn: '1h' }
    );

    user2Token = jwt.sign(
      { userId: user2Id, email: testUsers.user2.email },
      process.env.JWT_SECRET || 'weak-secret-key',
      { expiresIn: '1h' }
    );

    // Create test tasks for each user
    const user1Task = await prisma.task.create({
      data: {
        userId: user1Id,
        title: 'User 1 Private Task',
        description: 'This is confidential information for user 1',
        priority: 'HIGH',
        status: 'TODO'
      }
    });
    user1TaskId = user1Task.id;

    const user2Task = await prisma.task.create({
      data: {
        userId: user2Id,
        title: 'User 2 Secret Task',
        description: 'This contains sensitive data for user 2',
        priority: 'URGENT',
        status: 'IN_PROGRESS'
      }
    });
    user2TaskId = user2Task.id;

    // Create test comments
    const user1Comment = await prisma.comment.create({
      data: {
        taskId: user1TaskId,
        userId: user1Id,
        content: 'User 1 private comment'
      }
    });
    user1CommentId = user1Comment.id;

    const user2Comment = await prisma.comment.create({
      data: {
        taskId: user2TaskId,
        userId: user2Id,
        content: 'User 2 confidential comment'
      }
    });
    user2CommentId = user2Comment.id;
  });

  describe('Task IDOR Vulnerabilities', () => {
    test('should allow unauthorized task access via direct ID manipulation', async () => {
      // User 1 tries to access User 2's task
      const response = await request(app)
        .get(`/api/tasks/${user2TaskId}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200); // Should fail with 403, but vulnerable app returns 200

      expect(response.body.id).toBe(user2TaskId);
      expect(response.body.title).toBe('User 2 Secret Task');
      expect(response.body.description).toBe('This contains sensitive data for user 2');
      expect(response.body.userId).toBe(user2Id);
    });

    test('should allow unauthorized task modification', async () => {
      const maliciousUpdate = {
        title: 'Hacked by User 1',
        description: 'This task was modified by an unauthorized user',
        status: 'COMPLETED'
      };

      // User 1 tries to modify User 2's task
      const response = await request(app)
        .put(`/api/tasks/${user2TaskId}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .send(maliciousUpdate)
        .expect(200); // Should fail with 403, but vulnerable app allows it

      expect(response.body.title).toBe(maliciousUpdate.title);
      expect(response.body.description).toBe(maliciousUpdate.description);
      expect(response.body.status).toBe(maliciousUpdate.status);

      // Verify the task was actually modified in the database
      const updatedTask = await prisma.task.findUnique({
        where: { id: user2TaskId }
      });
      expect(updatedTask?.title).toBe(maliciousUpdate.title);
    });

    test('should allow unauthorized task deletion', async () => {
      // Create a task for User 2 to delete
      const taskToDelete = await prisma.task.create({
        data: {
          userId: user2Id,
          title: 'Task to be deleted',
          description: 'This will be deleted by unauthorized user',
          priority: 'LOW',
          status: 'TODO'
        }
      });

      // User 1 tries to delete User 2's task
      await request(app)
        .delete(`/api/tasks/${taskToDelete.id}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200); // Should fail with 403, but vulnerable app allows it

      // Verify the task was actually deleted
      const deletedTask = await prisma.task.findUnique({
        where: { id: taskToDelete.id }
      });
      expect(deletedTask).toBeNull();
    });

    test('should expose all tasks via ID enumeration', async () => {
      const accessibleTasks = [];
      
      // Try to access tasks with IDs around the known task IDs
      for (let id = Math.min(user1TaskId, user2TaskId) - 2; id <= Math.max(user1TaskId, user2TaskId) + 2; id++) {
        try {
          const response = await request(app)
            .get(`/api/tasks/${id}`)
            .set('Authorization', `Bearer ${user1Token}`);
          
          if (response.status === 200) {
            accessibleTasks.push(response.body);
          }
        } catch (error) {
          // Ignore errors for non-existent tasks
        }
      }

      // Should be able to access tasks from both users
      const user1Tasks = accessibleTasks.filter(task => task.userId === user1Id);
      const user2Tasks = accessibleTasks.filter(task => task.userId === user2Id);
      
      expect(user1Tasks.length).toBeGreaterThan(0);
      expect(user2Tasks.length).toBeGreaterThan(0); // This indicates IDOR vulnerability
    });
  });

  describe('Comment IDOR Vulnerabilities', () => {
    test('should allow unauthorized comment access', async () => {
      // User 1 tries to access User 2's comments
      const response = await request(app)
        .get(`/api/comments/task/${user2TaskId}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200); // Should fail with 403, but vulnerable app returns comments

      expect(response.body).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            id: user2CommentId,
            content: 'User 2 confidential comment',
            userId: user2Id
          })
        ])
      );
    });

    test('should allow unauthorized comment deletion', async () => {
      // User 1 tries to delete User 2's comment
      await request(app)
        .delete(`/api/comments/${user2CommentId}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200); // Should fail with 403, but vulnerable app allows it

      // Verify the comment was actually deleted
      const deletedComment = await prisma.comment.findUnique({
        where: { id: user2CommentId }
      });
      expect(deletedComment).toBeNull();
    });

    test('should allow unauthorized comment creation on other users tasks', async () => {
      const maliciousComment = {
        content: 'This comment was added by an unauthorized user'
      };

      // User 1 tries to add comment to User 2's task
      const response = await request(app)
        .post(`/api/comments/task/${user2TaskId}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .send(maliciousComment)
        .expect(201); // Should fail with 403, but vulnerable app allows it

      expect(response.body.content).toBe(maliciousComment.content);
      expect(response.body.taskId).toBe(user2TaskId);
      expect(response.body.userId).toBe(user1Id); // Comment created by User 1 on User 2's task
    });
  });

  describe('User Profile IDOR Vulnerabilities', () => {
    test('should allow unauthorized profile access', async () => {
      // This test assumes there's a profile endpoint that's vulnerable
      // User 1 tries to access User 2's profile by manipulating user ID in request
      
      // First, let's test if we can access other users' data through task listings
      const response = await request(app)
        .get('/api/tasks')
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200);

      // In a vulnerable app, this might return tasks from all users
      const allUserTasks = response.body;
      const otherUserTasks = allUserTasks.filter((task: any) => task.userId !== user1Id);
      
      // If we get tasks from other users, it's an IDOR vulnerability
      if (otherUserTasks.length > 0) {
        expect(otherUserTasks[0].userId).not.toBe(user1Id);
      }
    });
  });

  describe('Bulk IDOR Exploitation', () => {
    test('should allow bulk data extraction via automated ID enumeration', async () => {
      const extractedData = {
        tasks: [],
        comments: []
      };

      // Enumerate task IDs
      for (let taskId = 1; taskId <= 100; taskId++) {
        try {
          const taskResponse = await request(app)
            .get(`/api/tasks/${taskId}`)
            .set('Authorization', `Bearer ${user1Token}`);
          
          if (taskResponse.status === 200) {
            extractedData.tasks.push(taskResponse.body);
          }
        } catch (error) {
          // Continue enumeration
        }
      }

      // Enumerate comment IDs
      for (let commentId = 1; commentId <= 100; commentId++) {
        try {
          const commentResponse = await request(app)
            .delete(`/api/comments/${commentId}`)
            .set('Authorization', `Bearer ${user1Token}`);
          
          // If deletion succeeds, the comment existed and was accessible
          if (commentResponse.status === 200) {
            extractedData.comments.push({ id: commentId, deleted: true });
          }
        } catch (error) {
          // Continue enumeration
        }
      }

      // Verify we extracted data from multiple users
      const uniqueUserIds = new Set(extractedData.tasks.map((task: any) => task.userId));
      expect(uniqueUserIds.size).toBeGreaterThan(1); // Should access multiple users' data
    });

    test('should allow privilege escalation through IDOR', async () => {
      // Try to access admin or high-privilege user data
      // This simulates finding admin tasks through ID enumeration
      
      const adminTaskData = {
        title: 'Admin Secret Task',
        description: 'This contains administrative secrets',
        priority: 'URGENT',
        status: 'TODO'
      };

      // Create an admin task (simulating existing admin data)
      const adminTask = await prisma.task.create({
        data: {
          ...adminTaskData,
          userId: user2Id // Using user2 as "admin" for this test
        }
      });

      // User 1 (regular user) tries to access admin task
      const response = await request(app)
        .get(`/api/tasks/${adminTask.id}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200); // Vulnerable app allows access

      expect(response.body.title).toBe(adminTaskData.title);
      expect(response.body.description).toBe(adminTaskData.description);
    });
  });

  describe('IDOR in Search and Filtering', () => {
    test('should expose other users data in search results', async () => {
      // Search for terms that might be in other users' tasks
      const response = await request(app)
        .get('/api/tasks/search?query=Secret')
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200);

      // Should return User 2's task containing "Secret" in title
      const secretTasks = response.body.filter((task: any) => task.title.includes('Secret'));
      expect(secretTasks.length).toBeGreaterThan(0);
      
      // Verify we're seeing other users' data
      const otherUserSecretTasks = secretTasks.filter((task: any) => task.userId !== user1Id);
      expect(otherUserSecretTasks.length).toBeGreaterThan(0);
    });
  });

  describe('Advanced IDOR Techniques', () => {
    test('should allow parameter pollution for access control bypass', async () => {
      // Try accessing task with multiple user parameters
      const response = await request(app)
        .get(`/api/tasks/${user2TaskId}?userId=${user1Id}&userId=${user2Id}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200);

      expect(response.body.id).toBe(user2TaskId);
    });

    test('should allow HTTP method override for unauthorized operations', async () => {
      // Try using different HTTP methods to bypass access controls
      const deleteViaPost = await request(app)
        .post(`/api/tasks/${user2TaskId}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .set('X-HTTP-Method-Override', 'DELETE');

      // Even if this doesn't work, test that the endpoint doesn't properly validate methods
      expect([200, 404, 405].includes(deleteViaPost.status)).toBe(true);
    });

    test('should allow race condition exploitation for IDOR', async () => {
      // Create multiple simultaneous requests to exploit race conditions
      const promises = Array(5).fill(null).map(() =>
        request(app)
          .get(`/api/tasks/${user2TaskId}`)
          .set('Authorization', `Bearer ${user1Token}`)
      );

      const responses = await Promise.all(promises);
      
      // All requests should succeed due to lack of proper access control
      responses.forEach(response => {
        expect(response.status).toBe(200);
        expect(response.body.id).toBe(user2TaskId);
      });
    });
  });
});