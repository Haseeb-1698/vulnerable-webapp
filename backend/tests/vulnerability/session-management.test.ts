import request from 'supertest';
import { app } from '../../src/server';
import { prisma, setupTestDatabase, testUsers } from '../setup';
import jwt from 'jsonwebtoken';

describe('Session Management Vulnerability Tests', () => {
  let user1Id: number;
  let user2Id: number;

  beforeAll(async () => {
    const users = await setupTestDatabase();
    user1Id = users.user1.id;
    user2Id = users.user2.id;
  });

  describe('Weak JWT Secret Vulnerabilities', () => {
    test('should use predictable weak JWT secret', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUsers.user1.email,
          password: testUsers.user1.password
        })
        .expect(200);

      const token = response.body.token;
      expect(token).toBeDefined();

      // Decode the JWT to verify it uses weak secret
      const decoded = jwt.decode(token, { complete: true });
      expect(decoded).toBeDefined();
      expect(decoded?.header.alg).toBe('HS256');

      // Try to verify with common weak secrets
      const weakSecrets = [
        'secret',
        'weak-secret-key',
        'password',
        '123456',
        'jwt-secret',
        'your-256-bit-secret'
      ];

      let cracked = false;
      for (const secret of weakSecrets) {
        try {
          const verified = jwt.verify(token, secret);
          if (verified) {
            cracked = true;
            expect(verified).toBeDefined();
            break;
          }
        } catch (error) {
          // Continue trying other secrets
        }
      }

      // At least one weak secret should work
      expect(cracked).toBe(true);
    });

    test('should allow JWT token manipulation with known secret', async () => {
      const weakSecret = 'weak-secret-key';
      
      // Create a malicious token with elevated privileges
      const maliciousPayload = {
        userId: user1Id,
        email: testUsers.user1.email,
        role: 'admin', // Privilege escalation
        isAdmin: true
      };

      const maliciousToken = jwt.sign(maliciousPayload, weakSecret, { expiresIn: '1h' });

      // Use the malicious token to access protected resources
      const response = await request(app)
        .get('/api/tasks')
        .set('Authorization', `Bearer ${maliciousToken}`)
        .expect(200);

      expect(response.body).toBeDefined();
    });

    test('should allow token forgery for other users', async () => {
      const weakSecret = 'weak-secret-key';
      
      // Create a forged token for user2 while being user1
      const forgedPayload = {
        userId: user2Id,
        email: testUsers.user2.email
      };

      const forgedToken = jwt.sign(forgedPayload, weakSecret, { expiresIn: '1h' });

      // Use forged token to access user2's resources
      const response = await request(app)
        .get('/api/tasks')
        .set('Authorization', `Bearer ${forgedToken}`)
        .expect(200);

      // Should return user2's tasks
      expect(response.body).toBeDefined();
    });
  });

  describe('Long Token Expiration Vulnerabilities', () => {
    test('should issue tokens with excessively long expiration', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUsers.user1.email,
          password: testUsers.user1.password
        })
        .expect(200);

      const token = response.body.token;
      const decoded = jwt.decode(token) as any;
      
      // Check if token has long expiration (30 days or more)
      const issuedAt = decoded.iat;
      const expiresAt = decoded.exp;
      const tokenLifetime = expiresAt - issuedAt;
      const thirtyDaysInSeconds = 30 * 24 * 60 * 60;
      
      expect(tokenLifetime).toBeGreaterThanOrEqual(thirtyDaysInSeconds);
    });

    test('should accept expired tokens due to weak validation', async () => {
      const weakSecret = 'weak-secret-key';
      
      // Create an expired token
      const expiredPayload = {
        userId: user1Id,
        email: testUsers.user1.email,
        exp: Math.floor(Date.now() / 1000) - 3600 // Expired 1 hour ago
      };

      const expiredToken = jwt.sign(expiredPayload, weakSecret);

      // Try to use expired token (vulnerable app might not check expiration properly)
      const response = await request(app)
        .get('/api/tasks')
        .set('Authorization', `Bearer ${expiredToken}`);

      // Depending on implementation, might still work
      expect([200, 401].includes(response.status)).toBe(true);
    });
  });

  describe('Token Storage Vulnerabilities', () => {
    test('should return tokens in response body for localStorage storage', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUsers.user1.email,
          password: testUsers.user1.password
        })
        .expect(200);

      // Token should be in response body (vulnerable pattern)
      expect(response.body.token).toBeDefined();
      expect(typeof response.body.token).toBe('string');
      
      // Should NOT set httpOnly cookies (secure pattern)
      const cookies = response.headers['set-cookie'];
      if (cookies) {
        const tokenCookie = cookies.find((cookie: string) => cookie.includes('token'));
        expect(tokenCookie).toBeUndefined(); // Vulnerable app doesn't use secure cookies
      }
    });

    test('should not invalidate tokens on logout', async () => {
      // Login to get a token
      const loginResponse = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUsers.user1.email,
          password: testUsers.user1.password
        })
        .expect(200);

      const token = loginResponse.body.token;

      // Logout
      await request(app)
        .post('/api/auth/logout')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);

      // Try to use the same token after logout (should fail but vulnerable app allows it)
      const response = await request(app)
        .get('/api/tasks')
        .set('Authorization', `Bearer ${token}`)
        .expect(200); // Vulnerable: token still works after logout

      expect(response.body).toBeDefined();
    });
  });

  describe('Session Fixation Vulnerabilities', () => {
    test('should not regenerate session ID on login', async () => {
      // Get initial session
      const initialResponse = await request(app)
        .get('/api/tasks')
        .expect(401); // Should be unauthorized

      // Login with same session
      const loginResponse = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUsers.user1.email,
          password: testUsers.user1.password
        })
        .expect(200);

      // Session should be the same (vulnerable to session fixation)
      expect(loginResponse.body.token).toBeDefined();
    });

    test('should allow session hijacking via token reuse', async () => {
      // User 1 logs in
      const user1Login = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUsers.user1.email,
          password: testUsers.user1.password
        })
        .expect(200);

      const user1Token = user1Login.body.token;

      // Simulate token theft - another client uses the same token
      const hijackedResponse = await request(app)
        .get('/api/tasks')
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200);

      expect(hijackedResponse.body).toBeDefined();
      
      // Both sessions should work simultaneously (vulnerable)
      const originalResponse = await request(app)
        .get('/api/tasks')
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200);

      expect(originalResponse.body).toBeDefined();
    });
  });

  describe('Concurrent Session Vulnerabilities', () => {
    test('should allow unlimited concurrent sessions', async () => {
      const tokens = [];
      
      // Create multiple sessions for the same user
      for (let i = 0; i < 5; i++) {
        const response = await request(app)
          .post('/api/auth/login')
          .send({
            email: testUsers.user1.email,
            password: testUsers.user1.password
          })
          .expect(200);
        
        tokens.push(response.body.token);
      }

      // All tokens should be valid simultaneously
      for (const token of tokens) {
        const response = await request(app)
          .get('/api/tasks')
          .set('Authorization', `Bearer ${token}`)
          .expect(200);
        
        expect(response.body).toBeDefined();
      }

      expect(tokens.length).toBe(5);
    });

    test('should not invalidate old sessions when new ones are created', async () => {
      // Create first session
      const firstLogin = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUsers.user1.email,
          password: testUsers.user1.password
        })
        .expect(200);

      const firstToken = firstLogin.body.token;

      // Create second session
      const secondLogin = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUsers.user1.email,
          password: testUsers.user1.password
        })
        .expect(200);

      const secondToken = secondLogin.body.token;

      // Both tokens should still work
      await request(app)
        .get('/api/tasks')
        .set('Authorization', `Bearer ${firstToken}`)
        .expect(200);

      await request(app)
        .get('/api/tasks')
        .set('Authorization', `Bearer ${secondToken}`)
        .expect(200);
    });
  });

  describe('Token Refresh Vulnerabilities', () => {
    test('should not implement proper token refresh mechanism', async () => {
      const response = await request(app)
        .post('/api/auth/refresh')
        .send({})
        .expect(404); // Endpoint doesn't exist (vulnerable)

      expect(response.status).toBe(404);
    });

    test('should allow token reuse without refresh', async () => {
      const loginResponse = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUsers.user1.email,
          password: testUsers.user1.password
        })
        .expect(200);

      const token = loginResponse.body.token;

      // Use token multiple times without refresh
      for (let i = 0; i < 10; i++) {
        await request(app)
          .get('/api/tasks')
          .set('Authorization', `Bearer ${token}`)
          .expect(200);
      }
    });
  });

  describe('Authorization Header Vulnerabilities', () => {
    test('should accept malformed authorization headers', async () => {
      const loginResponse = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUsers.user1.email,
          password: testUsers.user1.password
        })
        .expect(200);

      const token = loginResponse.body.token;

      // Try various malformed headers
      const malformedHeaders = [
        `bearer ${token}`, // lowercase
        `Bearer  ${token}`, // extra space
        `Token ${token}`, // wrong prefix
        token // no prefix
      ];

      for (const header of malformedHeaders) {
        const response = await request(app)
          .get('/api/tasks')
          .set('Authorization', header);

        // Some might work due to loose validation
        expect([200, 401].includes(response.status)).toBe(true);
      }
    });

    test('should be vulnerable to JWT algorithm confusion', async () => {
      const weakSecret = 'weak-secret-key';
      
      // Create token with 'none' algorithm
      const noneAlgPayload = {
        userId: user1Id,
        email: testUsers.user1.email
      };

      // Manually create JWT with 'none' algorithm
      const header = Buffer.from(JSON.stringify({ alg: 'none', typ: 'JWT' })).toString('base64url');
      const payload = Buffer.from(JSON.stringify(noneAlgPayload)).toString('base64url');
      const noneToken = `${header}.${payload}.`;

      const response = await request(app)
        .get('/api/tasks')
        .set('Authorization', `Bearer ${noneToken}`);

      // Vulnerable implementation might accept 'none' algorithm
      expect([200, 401].includes(response.status)).toBe(true);
    });
  });

  describe('Cross-Site Request Forgery (CSRF) Vulnerabilities', () => {
    test('should not implement CSRF protection', async () => {
      const loginResponse = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUsers.user1.email,
          password: testUsers.user1.password
        })
        .expect(200);

      const token = loginResponse.body.token;

      // Simulate CSRF attack - request without CSRF token
      const csrfResponse = await request(app)
        .post('/api/tasks')
        .set('Authorization', `Bearer ${token}`)
        .set('Origin', 'http://malicious-site.com')
        .send({
          title: 'CSRF Created Task',
          description: 'This task was created via CSRF attack',
          priority: 'HIGH',
          status: 'TODO'
        })
        .expect(201); // Should succeed due to lack of CSRF protection

      expect(csrfResponse.body.title).toBe('CSRF Created Task');
    });

    test('should allow cross-origin requests without proper validation', async () => {
      const loginResponse = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUsers.user1.email,
          password: testUsers.user1.password
        })
        .expect(200);

      const token = loginResponse.body.token;

      const response = await request(app)
        .get('/api/tasks')
        .set('Authorization', `Bearer ${token}`)
        .set('Origin', 'http://evil.com')
        .expect(200);

      expect(response.body).toBeDefined();
    });
  });

  describe('Session Information Disclosure', () => {
    test('should expose sensitive information in JWT payload', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUsers.user1.email,
          password: testUsers.user1.password
        })
        .expect(200);

      const token = response.body.token;
      const decoded = jwt.decode(token) as any;

      // Check for sensitive information in JWT payload
      expect(decoded.userId).toBeDefined();
      expect(decoded.email).toBeDefined();
      
      // Vulnerable implementations might include sensitive data
      if (decoded.password || decoded.passwordHash) {
        expect(decoded.password || decoded.passwordHash).toBeDefined();
      }
    });

    test('should return user information in login response', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUsers.user1.email,
          password: testUsers.user1.password
        })
        .expect(200);

      // Should return user data (potentially sensitive)
      expect(response.body.user).toBeDefined();
      expect(response.body.user.email).toBe(testUsers.user1.email);
      
      // Should not return password hash
      expect(response.body.user.passwordHash).toBeUndefined();
    });
  });

  describe('Brute Force Protection Vulnerabilities', () => {
    test('should not implement rate limiting on login attempts', async () => {
      const attempts = [];
      
      // Try multiple failed login attempts
      for (let i = 0; i < 10; i++) {
        const attempt = request(app)
          .post('/api/auth/login')
          .send({
            email: testUsers.user1.email,
            password: 'wrong-password'
          });
        
        attempts.push(attempt);
      }

      const responses = await Promise.all(attempts);
      
      // All attempts should be processed (no rate limiting)
      responses.forEach(response => {
        expect(response.status).toBe(401);
      });
    });

    test('should not implement account lockout after failed attempts', async () => {
      // Multiple failed attempts
      for (let i = 0; i < 5; i++) {
        await request(app)
          .post('/api/auth/login')
          .send({
            email: testUsers.user1.email,
            password: 'wrong-password'
          })
          .expect(401);
      }

      // Account should still be accessible
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: testUsers.user1.email,
          password: testUsers.user1.password
        })
        .expect(200);

      expect(response.body.token).toBeDefined();
    });
  });
});